\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm,hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{aed2-symb,aed2-itef,aed2-tad}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}
\usepackage[conEntregas]{caratula}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}

\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}
\newcommand{\sombrero}[1]{\widehat{#1}}


\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripci\'{o}n:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representaci\'{o}n}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Title}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}

\titulo{Trabajo Pr\'{a}ctico}
\subtitulo{}

\fecha{\today}

\materia{Algoritmos y Estructura de Datos II}
\grupo{Grupo 13}

\integrante{Fosco, Martin Esteban}{449/13}{mfosco2005@yahoo.com.ar}
\integrante{Minces M\"{u}ller, Javier Nicol\'{a}s}{231/13}{javijavi1994@gmail.com}
\integrante{Murga, Christian Mariano}{982/12}{christianmmurga@gmail.com}
\integrante{Palladino, Julian Alberto}{336/13}{julianpalladino@hotmail.com}
% Pongan cuantos integrantes quieran

\maketitle

\section{M\'{o}dulo Promesa}
\begin{Interfaz}
  \textbf{se explica con}: \tadNombre{Promesa}.\\

  \textbf{g\'{e}neros}: \TipoVariable{promesa}.\\
 \Title{Operaciones}
  \InterfazFuncion{t\'{i}tulo} {\In{p}{promesa}}{nombre}
  {$res \igobs t\'{i}tulo(p)$}
  [$O(1)$]
  [Devuelve el nombre del t\'{i}tulo sobre el que se hizo la promesa]
  [res es modificable si y solo si p es modificable]
  
  \InterfazFuncion{tipo} {\In{p}{promesa}}{tipoPromesa}
  {$res \igobs tipo(p)$}
  [$O(1)$]
  [Devuelve 'comprar' si la promesa es de compra y 'vender' si no lo es]
  [res es modificable si y solo si p es modificable]
  
  \InterfazFuncion{l\'{i}mite} {\In{p}{promesa}}{dinero}
  {$res \igobs l\'{i}mite(p)$}
  [$O(1)$]
  [Devuelve el valor que la cotizaci\'{o}n tiene que superar para que se ejecute una promesa.]
  
  \InterfazFuncion{cantidad} {\In{p}{promesa}}{nat}
  {$res \igobs cantidad(p)$}
  [$O(1)$]
  [Devuelve la cantidad de acciones que se compran o se venden cuando la promesa se ejecuta]
  
  \InterfazFuncion{crearPromesa} {\In{n}{nombre},\ \In{t}{tipo},\ \In{l}{dinero},\ \In{c}{nat}}{promesa}
  {$res \igobs crearpromesa(n,t,l,c)$}
  [$O(1)$]
  [Si t es 'comprar', devuelve una promesa de comprar c acciones de n si su coitzaci\'{o}n supera l. Si t es 'vender', devuelve una promesa de vender c acciones de n si su cotizaci\'{o}n daja de l]
  [n y t son modificables si y solo si la promesa es modificable]
  
    \InterfazFuncion{promesaEjecutable} {\In{p}{promesa},\ \In{d}{dinero},\ \In{n}{nat}}{bool}
  {$res \igobs promesaEjecutable(p,d,n)$}
  [$O(1)$]
  [Si la promesa es de compra, devuelve true si y solo si la cotizaci\'{o}n del t\'{i}tulo de la promesa super\'{o} el l\'{i}mite y hay suficientes disponibles. Si la promesa es de venta, devuelve true si y solo si la cotizaci\'{o}n del t\'{i}tulo baj\'{o} del l\'{i}mite.]
  
   \InterfazFuncion{compraVenta} {\In{d}{nat},\ \In{ps}{conj(promesa)}}{nat}
  {$res \igobs compraVenta(d,ps)$}
  [$O($\#$(ps))$]
  [Devuelve la disponiblidad m\'{a}s la suma de cantidades de las promesas de compra de un conjunto, menos la suma de las cantidades de las promesas de venta de dicho conjunto.]
  
  \InterfazFuncion{promesasSobreT\'{i}tulo} {\In{n}{nombre},\ \In{t}{tipoPromesa},\ \In{ps}{conj(promesa)}}{conj(promesa)}
  {$res \igobs promesasSobreT\'{i}tulo(n,t,ps)$}
  [$O($\#$(ps))$]
  [Devuelve, de un conjunto de promesas, aquellas que son de un determinado tipo y t\'{i}tulo.]
  [Las promesas se devuelven por copia]
  
\end{Interfaz}
\begin{Representacion}
    \begin{Estructura}{promesa}[estr]
    \begin{Tupla}[promesa] 
      \tupItem{t\'{i}tulo}{nombre}
      \tupItem{tipo}{tipoPromesa}
      \tupItem{cantidad}{acciones}
      \tupItem{l\'{i}mite}{nat}
    \end{Tupla} 
    \end{Estructura}
      \Rep[estr][p]{true}\mbox{}
	  
	  Abs:estr p $\rightarrow$ promesa  \hfill $\{$ Rep(p) $\}$ \\
	  Abs(p) $\igobs$ p2:promesa|t\'{i}tulo(p2)=p.t\'{i}tulo \\$\wedge$ tipo(p2)=p.tipo \\$\wedge$ cantidad(p2)=p.cantidad\\$\wedge$ l\'{i}mite(p2)=p.l\'{i}mite
      
\end{Representacion}
\begin{Algoritmos}
\\
(Las complejidades junto a una asignacion representan el costo de evaluar y asignar. Las complejidades junto a un \textbf {if} o un \textbf{while} representan el costo de evaluar la guarda. Las complejidades junto a un \textbf{endwhile} representan el costo de todo el ciclo.)
\\
\NombreFuncion{iT\'{i}tulo}(\In{p}{estr}) $\rightarrow$ res:nombre
\\
\tab res $\leftarrow$ p.t\'{i}tulo \hfill O(1)
\\
\NombreFuncion{iTipo}(\In{p}{estr}) $\rightarrow$ res:tipoPromesa
\\
\tab res $\leftarrow$ p.tipo \hfill O(1)
\\
\NombreFuncion{iL\'{i}mite}(\In{p}{estr}) $\rightarrow$ res:dinero
\\
\tab res $\leftarrow$ p.l\'{i}mite \hfill O(1)
\\
\NombreFuncion{iCantidad}(\In{p}{estr}) $\rightarrow$ res:nat
\\
\tab res $\leftarrow$ p.cantidad \hfill O(1)
\\
\NombreFuncion{iCrearPromesa}(\In{n}{nombre},\ \In{t}{tipo},\ \In{l}{dinero},\ \In{c}{nat}) $\rightarrow$ res:estr
\\
\tab res.nombre $\leftarrow$ n \hfill O(1)
\\
\tab res.tipo $\leftarrow$ t \hfill O(1)
\\
\tab res.l\'{i}mite $\leftarrow$ l \hfill O(1)
\\
\tab res.cantidad $\leftarrow$ c \hfill O(1)
\\
\NombreFuncion{iPromesaEjecutable}(\In{p}{promesa},\ \In{d}{dinero},\ \In{n}{nat}) $\rightarrow$ res:bool
\\
\tab res $\leftarrow$ tipo(p)=venta $\wedge$ d < l\'{i}mite(p)) $\vee$
tipo(p) = compra $\wedge$ d > l\'{i}mite(p) $\wedge$ n $\geq$ cantidad(p) \hfill O(1)
\\
\NombreFuncion{iCompraVenta}(\In{d}{nat},\ \In{p}{conj(promesa)}) $\rightarrow$ res:nat
\\
\tab res $\leftarrow$ d \hfill O(1)
\\
\tab ps $\leftarrow$ crearIt(p) \hfill O(1)
\\
\tab \textbf{while} (hayMas?(ps)) \hfill O(1)
\\
\tab \tab \textbf{if} siguiente(ps).tipo=comprar \hfill O(1)
\\
\tab \tab \tab res $\leftarrow$ res+siguiente(ps).cantidad \hfill O(1)
\\
\tab \tab \textbf{else}
\\
\tab \tab \tab res $\leftarrow$ res-siguiente(ps).cantidad \hfill O(1)
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(ps) \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O($\#$(p))
\\
\NombreFuncion{iPromesasSobreT\'{i}tulo}(\In{n}{nombre},\ \In{t}{tipoPromesa},\ \In{p}{conj(promesa)}) $\rightarrow$ res:conj(promesa)
\\
\tab res $\leftarrow$ Vacio() \hfill O(1)
\\
\tab ps $\leftarrow$ crearIt(p) \hfill O(1)
\\
\tab \textbf{while} (hayMas?(ps)) \hfill O(1)
\\
\tab \tab \textbf{if} siguiente(ps).tipo=t $\wedge$ siguiente(ps).t\'{i}tulo=n \hfill O(1)
\\
\tab \tab \tab AgregarRapido(res,\ siguiente(ps)) \hfill O(1)
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(ps) \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O($\#$(p))
\\
\end{Algoritmos}

\section{M\'{o}dulo T\'{i}tulo}
\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{T\'{i}tulo}.\\

  \textbf{g\'{e}neros}: \TipoVariable{t\'{i}tulo}.\\

  \Title{Operaciones}
  \InterfazFuncion{nombre} {\In{t}{t\'{i}tulo}}{nombre}
  {$\sombrero{res} \igobs nombre(\sombrero{t})$}            %post
  [$O(1)$]                                                  %complejidad
  [Devuelve el nombre del t\'{i}tulo.]                        %descripcion
  [res es modificable si y solo si t es modificable.]
  \\   \\                                                    
  \tab \InterfazFuncion{cantMax}{\In{t}{t\'{i}tulo}}{nat}
  {$\sombrero{res}$\ $\igobs$\ $\#$m\'{a}xAcciones(t)}
  [$O(1)$]
  [Devuelve la cantidad m\'{a}xima de acciones disponibles para wolfie.]
  \\ \\
  \tab \InterfazFuncion{cot} {\In{t}{t\'{i}tulo}}{nat}
  {$\sombrero{res}$\ $\igobs$\ cotizaci\'{o}n($\sombrero{t}$)}
  [$O(1)$]
  [Devuelve la cotizaci\'{o}n actual del t\'{i}tulo.]
  \\ \\
  \tab \InterfazFuncion{enAlza}{\In{t}{t\'{i}tulo}}{bool}
  {$\sombrero{res}$\ $\igobs$\ enAlza($\sombrero{t}$)}
  [$O(1)$]
  [Devuelve true si la cotizaci\'{o}n del t\'{i}tulo al recotizar es mayor a la anterior, o si nunca se aplic\'{o} recotizar sobre ese t\'{i}tulo, y false en caso contrario.]
  \\ \\
  \tab \InterfazFuncion{nuevoT}{\In{nt}{nombre},\ \In{cot}{dinero},\ \In{cantMax}{nat}}{t\'{i}tulo}
  {nombre($\sombrero{res}$)\ $\igobs$\ $\sombrero{nt}$\ $\wedge$\ $\#$m\'{a}xAcciones($\sombrero{res}$)\ $\igobs$\ $\sombrero{cantMax}$\ $\wedge$\ cotizaci\'{o}n($\sombrero{res}$)\ $\igobs$\ $\sombrero{cot}$\ $\wedge$\ enAlza($\sombrero{res}$)\ $\igobs$\ true}
  [$O(1)$]
  [Crea un nuevo t\'{i}tulo cuyos nombre, cotizaci\'{o}n y cantidad de acciones disponibles son aquellos pasados por par\'{a}metro]
  [res es modificable si y solo si nt es modificable]
  \\ \\
  \tab \InterfazFuncion{recotizar}{\In{cot}{dinero},\ \Inout{t}{t\'{i}tulo}}{}
  [$\sombrero{t}$\ $\igobs$\ $t_0$]
  {$\sombrero{t}$\ $\igobs$\ recotizar($\sombrero{cot}$,\ $t_0$)}
  [$O(1)$]
  [Cambia la cotizaci\'{o}n del t\'{i}tulo por la cot que se indique]
  \\ \\
  \tab \InterfazFuncion{cotActual}{\In{nt}{nombre},\ \In{ts}{conj(t\'{i}tulo)}}{nat}
  [($\exists$\ t:t\'{i}tulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$)]
  {($\exists$\ t:t\'{i}tulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$\ $\wedge$\ cotizaci\'{o}n(t)\ $\igobs$\ $\sombrero{res}$ )}
  [$O(Cardinal(ts))$]
  [Devuelve la cotizaci\'{o}n del t\'{i}tulo cuyo nombre coincide con el pasado por par\'{a}metro]
  \\ \\
  \tab \InterfazFuncion{cambiarCotTs}{\In{nt}{nombre},\ \In{cot}{dinero},\ \Inout{ts}{conj(t\'{i}tulo)}}{}
  [($\exists$\ t:t\'{i}tulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$)\ $\wedge$\ $\sombrero{ts}$\ $\igobs$\ $ts_0$]
  {$\sombrero{ts}$\ $\igobs$\ cambiarCotizaci\'{o}n($\sombrero{nt}$,\ $\sombrero{cot}$,\ $ts_0$)}
  [$O(Cardinal(ts))$]
  [Cambia la cotizaci\'{o}n del t\'{i}tulo cuyo nombre coincide con el pasado por par\'{a}metro por la cotizaci\'{o}n (tambi\'{e}n pasada por par\'{a}metro)]
  \\ \\
  \tab \InterfazFuncion{limTen}{\In{nt}{nombre},\ \In{ts}{conj(t\'{i}tulo)}}{nat}
  [($\exists$\ t:t\'{i}tulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$)]
  {($\exists$\ t:t\'{i}tulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$\ $\wedge$\ $\#$m\'{a}xAcciones(t)\ $\igobs$\ $\sombrero{res}$ )}
  [$O(Cardinal(ts))$]
  [Devuelve la cantidad m\'{a}xima de acciones disponibles para wolfie del t\'{i}tulo cuyo nombre coincide con el pasado por par\'{a}metro]
  \\ \\
  \tab \InterfazFuncion{titEnAlza}{\In{nt}{nombre},\ \In{ts}{conj(t\'{i}tulo)}}{bool}
  [($\exists$\ t:t\'{i}tulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$)]
  {($\exists$\ t:t\'{i}tulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$\ $\wedge$\ enAlza(t)\ $\igobs$\ $\sombrero{res}$ )}
  [$O(Cardinal(ts))$]
  [Informa si las acciones del t\'{i}tulo cuyo nombre coincide con el pasado por par\'{a}metro est\'{a}n en alza ]
\end{Interfaz}\\ \\ \\
\begin{Representacion}
 \Title{Representaci\'{o}n}
    \begin{Tupla}[t\'{i}tulo] 
      \tupItem{nombre}{string}
      \tupItem{cantMax}{nat}
      \tupItem{cot}{nat}
      \tupItem{enAlza}{bool}
    \end{Tupla} 
    
      \Rep[estr][t]{true}\mbox{}  \\ \\
      Abs:estr t $\rightarrow$ t\'{i}tulo \hfill $\{$ Rep(t) $\}$ \\
	  Abs(t) $\igobs$ t2:t\'{i}tulo|nombre(t2)=t.nombre,\\$\wedge \#$maxAcciones(t2)=t.cantMax\\$\wedge$ cotizacion(t2)=t.cot \\$\wedge$ enAlza(t2)=t.enAlza
	  
	 \end{Representacion}
\begin{Algoritmos}
\\ \\
  \NombreFuncion{inombre}(\In{t}{t\'{i}tulo})$\rightarrow$ res:string
\\
\tab res\ $\leftarrow$\ t.nombre \hfill $O(1)$
\\ \\
  \NombreFuncion{icantMax}(\In{t}{t\'{i}tulo}) $\rightarrow$ res:nat
\end{Algoritmos}
\\ \\
\tab res\ $\leftarrow$\ t.cantMax \hfill $O(1)$
\\ \\
  \NombreFuncion{icot}(\In{t}{t\'{i}tulo})$\rightarrow$ res:nat
\\
\tab res\ $\leftarrow$\ t.cot \hfill $O(1)$
\\ \\
  \NombreFuncion{ienAlza}(\In{t}{t\'{i}tulo})$\rightarrow$ res:bool
\\
\tab res\ $\leftarrow$\ t.enAlza \hfill $O(1)$
\\ \\
  \NombreFuncion{inuevoT}(\In{nt}{nombre},\ \In{cantMax}{nat},\ \In{cot}{dinero})$\rightarrow$ res:estr
\\
\tab res.nombre\ $\leftarrow$\ nt \hfill $O(1)$
\\
\tab res.cantMax\ $\leftarrow$\ cantMax \hfill $O(1)$
\\
\tab res.cot\ $\leftarrow$\ cot \hfill $O(1)$
\\
\tab res.enAlza\ $\leftarrow$\ true \hfill $O(1)$
\\ \\
  \NombreFuncion{irecotizar}(\In{cot}{dinero},\ \Inout{t}{estr})
\\
\tab t.enAlza\ $\leftarrow$\ cot>t.cot \hfill $O(1)$
\\
\tab t.cot\ $\leftarrow$\ cot \hfill $O(1)$
\\ \\
  \NombreFuncion{icotActual}(\In{nt}{nombre},\ \In{ts}{conj(estr)})\ $\rightarrow$\ res:nat
\\
\tab it\ $\leftarrow$ CrearIt(ts) \hfill $O(1)$
\\
\tab while(HaySiguiente(it)) 
\\
\tab \tab \textbf{if}(nombre(Siguiente(ts))\ =\ nt) \hfill $O(1)$
\\
\tab \tab \tab res\ $\leftarrow$\ Siguiente(ts).cot \hfill $O(1)$
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(it) \hfill $O(1)$
\\
\tab \textbf{endwhile} \hfill $O(Cardinal(ts))$
\\ \\
  \NombreFuncion{iCambiarCotTs}(\In{nt}{nombre},\ \In{cot}{dinero},\ \Inout{ts}{conj(estr)})
\\
\tab it\ $\leftarrow$ CrearIt(ts) \hfill $O(1)$
\\
\tab while(HaySiguiente(it)) 
\\
\tab \tab \textbf{if}(nombre(Siguiente(ts))\ =\ nt) \hfill $O(1)$
\\
\tab \tab \tab Siguiente(ts).enAlza\ $\leftarrow$\ Siguiente(ts).cot<cot \hfill $O(1)$
\\
\tab \tab \tab Siguiente(ts).cot\ $\leftarrow$\ cot \hfill $O(1)$
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(it) \hfill $O(1)$
\\
\tab \textbf{endwhile} \hfill $O(Cardinal(ts))$
\\ \\
  \NombreFuncion{ilimTen}(\In{nt}{nombre},\ \In{ts}{conj(estr)})
\\
\tab it\ $\leftarrow$ CrearIt(ts) \hfill $O(1)$
\\
\tab while(HaySiguiente(it)) \hfill $O(1)$
\\
\tab \tab \textbf{if}(nombre(Siguiente(ts))\ =\ nt) \hfill $O(1)$
\\
\tab \tab \tab res\ $\leftarrow$\ Siguiente(ts).cantMax \hfill $O(1)$
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(it) \hfill $O(1)$
\\
\tab \textbf{endwhile} \hfill $O(Cardinal(ts))$
\\ \\
  \NombreFuncion{ititEnAlza}(\In{nt}{nombre},\ \In{ts}{conj(estr)})
\\
\tab it\ $\leftarrow$ CrearIt(ts) \hfill $O(1)$
\\
\tab while(HaySiguiente(it)) \hfill $O(1)$
\\
\tab \tab \textbf{if}(nombre(Siguiente(ts))\ =\ nt) \hfill $O(1)$
\\
\tab \tab \tab res\ $\leftarrow$\ Siguiente(ts).enAlza \hfill $O(1)$
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(it) \hfill $O(1)$
\\
\tab \textbf{endwhile} \hfill $O(Cardinal(ts))$
\\




\section{M\'{o}dulo Wolfie}


\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{Wolfie}.\\

  \textbf{g\'{e}neros}: \TipoVariable{wolfie}.\\

  \Title{Operaciones}

  \InterfazFuncion{Clientes}{\In {w}{wolfie}}{itBi(cliente)}
  {$\sombrero{res} \igobs clientes(\sombrero{w})$}
  [O(1)]
  [Devuelve un iterador de los clientes de wolfie.]
  [Al ser nats, se pasan por copia.]

  \InterfazFuncion{T\'{i}tulos}{\In {w}{wolfie}}{itUni(t\'{i}tulo)}
  {$\sombrero{res} \igobs T$\'{i}$tulos(\sombrero{w})$}
  [O(1)]
  [Devuelve un iterador de los t\'{i}tulos de wolfie.]
  [Los t\'{i}tulos se pasan por referencia. Res es modificable si los t\'{i}tulos son modificables.]

  \InterfazFuncion{promesasDe} {\In {c}{cliente}, \In {w}{wolfie}} {itBi(promesa)}
  [$\sombrero{c} \in clientes(\sombrero{w})$]
  {$res \igobs promesasDe(c,w)$}
  [$O(T \cdot C \cdot |max_nt|)$ y O(1) para sucesivas llamadas con el mismo c, salvo que se use actualizarCotizacion antes]
  [Devuelve todas las promesas del cliente c]
  [Las promesas se pasan por copia.]
  
  \InterfazFuncion{accionesPorCliente}{\In {c}{cliente}, \In {nt}{nombre}, \In {w}{wolfie}}{nat}
  [$\sombrero{c} \in clientes(\sombrero{w}) \wedge (\exists t: $t\'{i}tulo)$(t \in\ $t\'{i}tulos$(\sombrero{w}) \wedge nombre(t) = \sombrero{nt})$]
  {$\sombrero{res} \igobs accionesPorCliente(\sombrero{c}, \sombrero{nt}, \sombrero{w})$}
  [$O(log(C)+|nt|)$]
  [Devuelve las acciones que tiene el cliente c del t\'{i}tulo cuyo nombre es nt]

  \InterfazFuncion{Inaugurar Wolfie}{\In {cs}{conj(cliente)}}{wolfie}
  [$\neg \emptyset  $($\sombrero{cs}$)]
  {$\sombrero{res} \igobs inaugurarWolfie(\sombrero{cs}$)}
  [$O(\# cs^{2})$]
  [Crea un wolfie cuyos clientes son los de cs, sin t\'{i}tulos ni promesas.]
  [Los elementos de cs se agregan por copia.]

  \InterfazFuncion{agregarT\'{i}tulo}{\In {t}{t\'{i}tiulo}, \Inout {w}{wolfie}}{}
  [$\sombrero{w} \igobs w_0 \yluego (\forall\ t2: $t\'{i}tulo$)(t \in\ $t\'{i}tulos$(\sombrero{w}) \Rightarrow nombre(\sombrero{t}) \neq nombre(t2)) $]
  {$w \igobs agregarT$\'{i}$tulo(\sombrero{t},w_0)$}
  [$O(|nombre(t)| + C)$]
  [Agrega el t\'{i}tulo t a los t\'{i}tulos de wolfie]
  [El elemento t se agrega por copia.]

  \InterfazFuncion{actualizarCotizaci\'{o}n}{\In {nt}{nombre}, \In {cot}{nat}, \Inout {w}{wolfie}}{}
  [$\sombrero{w} \igobs w_0 \yluego \exists(t: t$\'{i}$tulo)(t \in t$\'{i}$tulos(\sombrero{w}) \wedge nombre(t) = \sombrero{nt}) $]
  {$\sombrero{w} \igobs actualizarCotizaci$\'{o}$n (\sombrero{nt}, \sombrero{cot}, w_0)$}
  [$O(|nt| + C \cdot log(C))$]
  [Cambia la cotizaci\'{o}n del t\'{i}tulo nt por cot. Actualiza EnAlza y ejecuta las promesas]
  [El elemento nt se pasa por copia]

  \InterfazFuncion{agregarPromesa}{\In {c}{cliente}, \In {p}{promesa}, \Inout {w}{wolfie}}{}
  [$\sombrero{w} \igobs w_0 \yluego (\exists t: t$\'{i}$tulo)(t \in t$\'{i}$tulos(\sombrero{w}) \wedge nombre(t) = t$\'{i}$tulo(\sombrero{p})) \wedge \sombrero{c} \in clientes(\sombrero{w}) \yluego (\forall p2: promesa)(p2 \in promesasDe(\sombrero{c}, \sombrero{w}) \Rightarrow (t$\'{i}$tulo(\sombrero{p}) \neq t$\'{i}$tulo(p2) \vee tipo(\sombrero{p}) \neq tipo(p2)) ) \wedge (tipo(\sombrero{p}) = vender \Rightarrow accionesPorCliente(\sombrero{c}, t$\'{i}$tulo(\sombrero{p}), \sombrero{w}) \geq cantidad(\sombrero{p}) ) )$]
  {$\sombrero{w} \igobs agregarPromesa (\sombrero{nt}, \sombrero{cot}, w_0)$}
  [$O(|t\'{i}tulo(p)| + log(C))$]
  [Agrega la promesa p al cliente c]
  [La promesa se pasa por copia]

  \InterfazFuncion{enAlza}{\In {nt}{nombre}, \In {w}{wolfie}}{bool}
  [$\exists(t: t$\'{i}$tulo)(t \in t$\'{i}$tulos(\sombrero{w}) \wedge nombre(t) = \sombrero{nt}) $]
  {$\sombrero{res} \igobs enAlza (\sombrero{nt}, \sombrero{w})$}
  [$O(|nt|)$]
  [Devuelve true si el t\'{i}tulo cuyo nombre es nt est\'{a} en alza, es decir, o bien su cotizaci\'{o}n es mayor a la que ten\'{i}a al ejecutar por \'{u}ltima vez actualizarCotizacion sobre ese t\'{i}tulo, o bien nunca se actualiz\'{o} su cotizaci\'{o}n]

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{wolfie}[estr]
    \begin{Tupla}[estr]
      \tupItem{clientes}{conj(cliente)}\\
      \tupItem{t\'{i}tulos}{conj(string)}\\
      \tupItem{datosT\'{i}tulo}{diccT(string,tupla<t\'{i}tulo:t\'{i}tulo, cantWolfie:acciones, diccCli:diccOrd(cliente,\ datosCliente)>)}\\
      \tupItem{accTxCliente}{diccOrd(cliente, acciones)}\\
      \tupItem{promUlt}{conj(tupla<cliente:cliente,\ promesas:conj(promesa)>)}
    \end{Tupla}

  \end{Estructura}
  
  \begin{Tupla}[datosCliente]
      \tupItem{acc}{acciones}\\
      \tupItem{pCompra}{conj(promesa)}\\
      \tupItem{pVenta}{conj(promesa)}
    \end{Tupla}
\\ \\ \\
\textbf{Descripcion del Rep:}
\\ \\
\textbf{1)} Los clientes de w.Clientes son los mismos que las claves de w.accTxCliente y que las claves de diccCli para todo t\'{i}tulo. Ademas son no vacios.
\\ \\
\textbf{2)} Los nombres de w.T\'{i}tulos son los mismos que las claves de w.datosT\'{i}tulo.
\\ \\
\textbf{3)} Para todo cliente de W, la suma de sus acciones de todos los t\'{i}tulos es igual a su significado en
w.accTxCliente
\\ \\
\textbf{4)} La suma de las acciones de todos los clientes sobre un t\'{i}tulo es igual a cantWolfie de ese t\'{i}tulo 
\\ \\
\textbf{5)} Wolfie no puede tener mas acciones de un t\'{i}tulo que la cantidad maxima de ese t\'{i}tulo.
\\ \\
\textbf{6)} En cada significado de datosCliente no puede existir una promesa de Venta con una cantidad mayor a las acciones del cliente sobre el t\'{i}tulo.
\\ \\
\textbf{7)} Para cada significado de datosCliente, pCompra y pVenta son conjuntos vacios o de longitud 1. En pCompra solo puede haber de compra y en pVenta, de venta. Asimismo, el t\'{i}tulo de las promesas deben corresponder con la clave. (Dividimos en 7.1 para venta y 7.2 para compra)
\\ \\
\textbf{8)} PromUlt es vacio o de longitud 1 y tiene las promesas de un cliente sobre todos los t\'{i}tulos.
\\ \\
\textbf{9)} Los nombres de datosT\'{i}tulo corresponden con el nombre del t\'{i}tulo.
\\ \\ \\	
  \Rep[estr][w]{\textbf{1)}($\forall$ t:nombre) t $\in$ claves(w.datosT\'{i}tulo) $\Rightarrow (\forall$ c:cliente) c $\in$ clientes $\Leftrightarrow$ def?(c,\ w.accTxCliente) $\Leftrightarrow$ def? (c,obtener(t,\ w.datosT\'{i}tulo))) $\wedge \neg \emptyset$?(w.clientes)\\ \\
  \textbf{2)} $\wedge (\forall$ t:nombre) t $\in$ w.t\'{i}tulos $\Leftrightarrow$ t $\in$ claves(w.datosT\'{i}tulo)\\ \\
  \textbf{3)} $\wedge (\forall$ c:cliente) c $\in$ w.clientes $\impluego$ obtener(c,\ w.accTxCliente) = $\sum_{t \in w.t\'{i}tulos}^{}$ (obtener(c, (obtener(nombre(t), w.diccT\'{i}tulo)).datosCliente).acc) \\ \\
  \textbf{4)} $\wedge (\forall$ t:nombre) (def?(t, w.datosT\'{i}tulo)) $\impluego$ obtener(t,w.datosT\'{i}tulo).accWolfie = $\sum_{c \in clientes(c)}^{}$ TitXCli(c,t,w).acc \\ \\
  \textbf{5)} $\wedge (\forall$ t:nombre) (t $\in$ w.t\'{i}tulos) $\impluego$ (cantMax(obtener(t,datosT\'{i}tulo)).t\'{i}tulo) $\leq$ (obtener(t,w.datosT\'{i}tulo).cantWolfie))\\ \\
  \textbf{6)} $\wedge (\forall$ c:cliente, t:nombre) (c $\in$ w.clientes $\wedge$ def?(t,w.datosT\'{i}tulo) $\yluego \neg \emptyset$?(TitXCli(c,t,w)).pVenta) $\impluego$ cantidad(dameUno(TitXCli(c,t,w).pVenta)) $\leq$ TitXCli(c,t,w).acc \\ \\
  \textbf{7.1)} $\wedge (\forall$ c:cliente, t:nombre) (c $\in$ w.clientes $\wedge$ def?(t,w.datosT\'{i}tulo)) $\impluego$ ($\neg \emptyset$?(TitXCli(c,t,w)).pVenta $\impluego (\#$(TitXCli(c,t,w).pVenta)=1 $\wedge$ tipo(dameUno(TitXCli(c,t,w).pVenta))=vender) $\wedge$ (nombre(dameUno(TitXCli(c,t,w).pVenta))=t) \\
  \textbf{7.2)}$\wedge \neg \emptyset$?(TitXCli(c,t,w)).pCompra $\impluego (\#$(TitXCli(c,t,w).pCompra)=1 $\wedge$ tipo(dameUno(TitXCli(c,t,w).pCompra))=comprar)) $\wedge$ (nombre(dameUno(TitXCli(c,t,w).pCompra))=t)  \\ \\
  \textbf{8)}$\wedge$ ($\emptyset$?(w.promUlt) $\oluego$ ((w.promUlt)=1 $\wedge$ (w.promUlt).cliente $\in$ w.clientes) $\yluego (\forall$ p:promesa) p $\in$ (dameUno(w.promUlt).promesas) $\Leftrightarrow (\exists$ n:nombre) ($\neg \emptyset$? (TitXCli(dameUno(w.promUlt).cliente,n,w).pCompra) $\yluego$ dameUno(TitXCli(dameUno(w.promUlt).cliente,n,w).pCompra)=p $\vee \neg \emptyset$? (TitXCli(dameUno(w.promUlt).cliente,n,w).pVenta) $\yluego$ dameUno(TitXCli(dameUno(w.promUlt).cliente,n,w).pVenta)=p) \\ \\
  \textbf{9)} $\wedge (\forall$ t:nombre) def?(t,w.datosT\'{i}tulo) $\impluego$ nombre(obtener(t,w.datosT\'{i}tulo).t\'{i}tulo)=t \\ 
  
  }\mbox{} 
    
  \NombreFuncion{TitXCli} (c:cliente, t:nombre, w:wolfie) $\rightarrow$ datosCliente \\
  TitXCli(c,t,w) = obtener(c,obtener(t, w.datosT\'{i}tulo).datosCliente) \\ \\
  
  
   Abs:estr w $\rightarrow$ wolfie \hfill $\{$ Rep(w) $\}$ \\
   Abs(w)$\igobs$ w2:wolfie|clientes(w2)=w.clientes\\$\wedge$ t\'{i}tulos(w2)=$\bigcup_{t \in w.t\'{i}tulos}(obtener(t,datosT\'{i}tulo).t\'{i}tulo)$,\\$\wedge$ ($\forall$ c:cliente) c $\in$ clientes(w2) $\impluego$ promesasDe(w2,c)=($\bigcup_{t \in w.t\'{i}tulos}$ TitXCli(c,t,w).pVenta) $\cup$ ($\bigcup_{t \in w.t\'{i}tulos}$ TitXCli(c,t,w).pVenta)\\$\wedge$ ($\forall$ c:cliente, nt:nombre) (c $\in$ clientes(w2) $\wedge (\exists$ t:t\'{i}tulo) (nombre(t)=nt $\wedge$ t $\in$ t\'{i}tulos(w2))) $\impluego$ Accionesporcliente(c,nt,w2)=obtener(c,(obtener(nt,e.datosT\'{i}tulo)).acc)


\end{Representacion}

\begin{Algoritmos}
\\
\NombreFuncion{iClientes}(\In{w}{estr}) $\rightarrow$ res:itConj(cliente)
\\
\tab res $\leftarrow$ crearIt(w.clientes) \hfill O(1)
\\ \\
\NombreFuncion{iT\'{i}tulos}(\In{w}{estr}) $\rightarrow$ res:itDiccT(t\'{i}tulos)
\\
\tab res $\leftarrow$ crearIt(w.datosT\'{i}tulo) \hfill O(1)
\\ \\
\NombreFuncion{PromesasDe}(\In{c}{cliente}, \Inout{w}{estr}) $\rightarrow$ res:itConj(promesa)
\\
\tab prom $\leftarrow$ Vacio() \hfill O(1)
\\ 
\tab \textbf {if} esVacio?(w.promUlt) $\oluego$ siguiente(crearIt(w.promUlt)).cliente $\neq$ c \hfill O(1)
\\
\tab \tab t $\leftarrow$ crearIt(w.t\'{i}tulos) \hfill O(1)
\\
\tab \tab \textbf{while} hayMas(t) \hfill O(1)
\\
\tab \tab \tab datosCli $\leftarrow$ significado(c, significado(siguiente(t),\ w.datosT\'{i}tulo).diccCli) \hfill O(|nt|+log(C))
\\
\tab \tab \tab \textbf{if} $\neg$ esVacio(datosCli.pCompra) \hfill O(1)
\\
\tab \tab \tab \tab agregarRapido(prom,\ siguiente(crearIt(datosCli.pCompra))) \hfill O(1)
\\
\tab \tab \tab \textbf{endif}
\\
\tab \tab \tab \textbf{if} $\neg$ esVacio(datosCli.pVenta) \hfill O(1)
\\
\tab \tab \tab \tab agregarRapido(prom,\ siguiente(crearIt(datosCli.pVenta))) \hfill O(1)
\\
\tab \tab \tab \textbf{endif} 
\\
\tab \tab \tab avanzar(t) \hfill O(1)
\\
\tab \tab \textbf{endwhile} \hfill O(T(log(C) + |max$\_$nt|))
\\
\tab \tab res $\leftarrow$ crearIt(prom) \hfill O(1)
\\
\tab \tab w.promUlt $\leftarrow$ Vacio() \hfill O(1)
\\
\tab \tab agregarRapido(w.promUlt,\ <c,prom>) \hfill O(1)
\\
\tab \textbf{else}
\\
\tab \tab res $\leftarrow$ crearIt(siguiente(crearIt(w.promUlt)).promesas) \hfill O(1)
\\
\tab \textbf{endif}
\\ \\
\NombreFuncion{iAccionesPorCliente}(\In{c}{cliente},\ \In {nt}{nombre},\ \In {w}{estr}) $\rightarrow$ (res:nat)
\\
\tab datoCli $\leftarrow$ significado(nt, w.datosT\'{i}tulo).diccCli \hfill O(|nt|)
\\
\tab res $\leftarrow$ significado(c,\ datoCli).acc \hfill O(log(C))
\\
\textbf{complejidad total}: O(|nt|+log(C))
\\ \\
\NombreFuncion{iInaugurarWolfie}(\In{cl}{conj(cliente)}) $\rightarrow$ (res:estr)
\\
\tab cs $\leftarrow$ crearIt(cl) \hfill O(C $\cdot$ log(C))
\\
\tab \textbf{while} haySiguiente(cs) \hfill O(1)
\\
\tab \tab agregarRapido(res.clientes,\ siguiente(cs)) \hfill O(1)
\\
\tab \tab definir(res.accTxCliente, siguiente(cs),0) \hfill O(C)
\\
\tab \tab avanzar(cs) \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O($\#(cl)^{2}$)
\\
\tab res.t\'{i}tulos $\leftarrow$ Vacio() \hfill O(1)
\\
\tab res.promUlt $\leftarrow$ Vacio() \hfill O(1)
\\
\textbf{Complejidad total}: O($\#(cl)^{2}$)
\\ \\
\NombreFuncion{iAgregarT\'{i}tulo}(\In{t}{t\'{i}tulo},\ \Inout{w}{estr})
\\
\tab t2 $\leftarrow$ crearT\'{i}tulo(nombre(t),cot(t),cantMax(t)) \hfill O(1)
\\
\tab agregarRapido(w.t\'{i}tulos,\ nombre(t)) \hfill O(1)
\\
\tab definir(w.datosT\'{i}tulo,\ nombre(t2),\ <t2,\ 0,\ CrearDiccAccC(w.accTxCliente, <0,\ Vacio(),\ Vacio()>)>) \hfill O(|nt|+C) 
\\
\textbf{Complejidad Total}: O(|nt|+C)
\\ \\
\NombreFuncion{crearDiccAccC} (\In{cs}{diccOrd(cliente,\ acciones)}, \In{t}{tupla<nat,\ conj(promesa),\ conj(promesa)>}) $\rightarrow$ res:diccOrd(cliente,tupla<nat,\ conj(promesa),\ conj(promesa)>)
\textbf{pre} $\equiv \{$ true $\}$
\\
\textbf{post} $\equiv \{ (\forall$ c:cliente) definido?(c, res) $\impluego$ obtener(c, res)=t $\}$
\\
\tab c $\leftarrow$ crearIt(cs)
\\
\tab \textbf {while} haySiguiente(cs) \hfill O(1)
\\
\tab \tab definirRapido(siguiente(cs),t) \hfill O(1)
\\
\tab \tab avanzar(cs)  \hfill O(1)
\\
\tab \textbf {endwhile}  \hfill O(C)
\\ \\
	
\NombreFuncion{iActualizarCotizaci\'{o}n}(\In{nt}{string},\ \In{cot}{nat},\ \Inout{w}{estr})

\tab datos $\leftarrow$ significado(nt,\ w.datosT\'{i}tulo) \hfill O(|nt|)
\\ 
\tab (datos.t\'{i}tulo) $\leftarrow$ recotizar(datos.t\'{i}tulo) \hfill O(1)
\\
\tab itDiccCli $\leftarrow$ crearIt(datos.diccCli)
\\
\tab \textbf{while} hayMas?(itDiccCli) \hfill O(1)
\\
\tab \tab dcli $\leftarrow$ siguienteSignificado(itDiccCli) \hfill O(1) 
\\
\tab \tab c $\leftarrow$ siguienteClave(itDiccCli) \hfill O(1) 
\\
\tab \tab \textbf{if} $\#$(dcli.pVenta)>0 $\yluego$ (promesaEjecutable(siguiente(crearIt(dcli.pCompra))), cot, ((datos.t\'{i}tulo).cantMax)-(datos.accWolfie)) \hfill O(1)
\\
\tab \tab \tab significado(c,\ w.accTxCliente) $\leftarrow$ significado(c,\ w.accTxCliente-cantidad(siguiente(crearIt(dcli.pVenta))) \hfill O(log(C))
\\
\tab \tab \tab dcli.acc $\leftarrow$ dcli.acc-cantidad(siguiente(crearIt(dcli.pVenta))) \hfill O(1)
\\
\tab \tab \tab dcli.pVenta $\leftarrow$ Vacio() \hfill O(1)
\\
\tab \tab \tab w.PromUlt $\leftarrow$ Vacio() \hfill O(1)
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(itDiccCli) \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O(C $\cdot$ log(C))
\\
\tab arreglo(cliente, acciones) cliO $\leftarrow$ diccOrd2ArrOrd(w.accTxCliente) \hfill O(C $\cdot$ log(C))
\\
\tab nat i $\leftarrow$ 0 \hfill O(1)
\\
\tab \textbf{while} i<longitud(CliO) \hfill O(1)
\\
\tab \tab dcli $\leftarrow$ significado(siguienteClave(cliO),datos.diccCli) \hfill O(log(C)) 
\\
\tab \tab c $\leftarrow$ siguienteClave(datos.diccCli) \hfill O(1) 
\\
\tab \tab \textbf{if} $\#$(dcli.pCompra)>0 $\yluego$ (promesaEjecutable(siguiente(crearIt(dcli.pCompra))), cot, ((datos.t\'{i}tulo).cantMax)-(datos.accWolfie)) \hfill O(1)
\\
\tab \tab \tab significado(c,\ w.accTxCliente) $\leftarrow$ significado(c,\ w.accTxCliente+cantidad(siguiente(crearIt(dcli.pCompra))) \hfill O(log(C))
\\
\tab \tab \tab dcli.acc $\leftarrow$ dcli.acc+cantidad(siguiente(crearIt(dcli.Compra))) \hfill O(1)
\\
\tab \tab \tab dcli.pCompra $\leftarrow$ Vacio() \hfill O(1)
\\
\tab \tab \tab w.PromUlt $\leftarrow$ Vacio() \hfill O(1)
\\
\tab \tab \textbf{endif}
\\
\tab \tab i $\leftarrow$ i+1 \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O(C $\cdot$ log(C))
\\
\textbf{Complejidad Total}: O(|nt|+C $\cdot$ log(C))
\\ \\
\NombreFuncion{diccOrd2ArrOrd}(\In{d}{diccOrd(cliente,\ acciones)}) $\rightarrow$ res:arreglo(tupla<(cliente,\ acciones)>)
\\
\textbf{Pre} $\equiv$ \{ $\neg$ esVacio?(d) \}
\\
\textbf{Post} $\equiv$ \{ ($\forall$ i, j: nat) (i<longitud(res)) $\wedge$ (j<longitud(res)) $\impluego$ ($\Pi_2$(res[i])$\leq \Pi_2$(res[j]) \} 
\\
\tab i $\leftarrow$ 0 \hfill O(1)
\\
\tab di $\leftarrow$ crearIt(d) \hfill O(1)
\\
\tab arr $\leftarrow$ crearArreglo($\#$claves(d)) \hfill O(1)
\\
\tab \textbf {while} i < $\#$claves(d)) \hfill O(1)
\\
\tab \tab arr[i]=<siguienteClave(di), siguienteSignificado(di)> \hfill O(1)
\\
\tab \tab i $\leftarrow$ i+1 \hfill O(1)
\\
\tab \tab avanzar(di) \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O(C)
\\
\tab res $\leftarrow$ Mergesort(arr) \hfill O(C $\cdot$ log(C)), Mergesort es igual al Mergesort apunte de algoritmos basicos pero aplicada sobre un arreglo de tuplas en vez de naturales. Sin embargo, como los segundos elementos de la tupla son nat, comparar dos tuplas por el segundo elemento cuesta O(1). 
\\ \\

\NombreFuncion {Merge}(\In{b}{arreglo(tupla<cliente, acciones>)}, \In{c}{arreglo\\(tupla<cliente, acciones>}) $\rightarrow$ res:arreglo(tupla<cliente, acciones>)
\\
\tab nat ib $\leftarrow$ 1;
\\
\tab nat ic $\leftarrow$ 1
\\
\tab res $\leftarrow$ CrearArreglo(tam(b) + tam(c))
\\
\tab nat i $\leftarrow$ 1
\\
\tab \textbf {while} i $\leq$ tam(a)
\\
\tab \tab \textbf {if} iB $\leq$ tam(b) $\wedge$ (ic > tam(c) $\vee \Pi_2$ b[ib] < $\Pi_2$c[ic])
\\
\tab \tab \tab res[i] $\leftarrow$ b[ib]
\\
\tab \tab \tab ib $\leftarrow$ ib + 1
\\
\tab \tab \textbf{else}
\\
\tab \tab \tab res[i] $\leftarrow$ c[ic]
\\
\tab \tab \tab ic $\leftarrow$ iC + 1
\\
\tab \tab \textbf{endif}
\\
\tab \tab i $\leftarrow$ i+1
\\
\tab \textbf {endwhile}
\\ \\

\NombreFuncion{MergeSort} (\Inout {a}{arreglo(tupla<cliente, acciones>)})
\\
\tab \textbf{if} tam(a)>1
\\
\tab \tab nat m $\leftarrow$ tam(a)/2
\\
\tab \tab arreglo(nat) b $\leftarrow$ Copiar(Subarreglo(a, 1, m))
\\
\tab \tab arreglo(nat) c $\leftarrow$ Copiar(Subarreglo(a, m+1; tam(a)))
\\
\tab \tab MergeSort(b)
\\
\tab \tab MergeSort(c)
\\
\tab \tab a $\leftarrow$ Merge(b, c)
\\
\tab \textbf{endif}
\\ \\


\NombreFuncion{iAgregarPromesa}(\In{p}{promesa},\ \In{c}{cliente},\ \Inout{w}{estr})
\\ 
\tab datos $\leftarrow$ significado(c,\ (significado(t\'{i}tulo(p),\ w.datosT\'{i}tulo))) \hfill O(log(C)+|nt|)
\\
\tab \textbf{if} (tipo(p)=vender) \hfill O(1)
\\
\tab \tab agregarRapido(datos.pVenta,\ p) \hfill O(1)
\\
\tab \textbf{else}
\\
\tab \tab agregarRapido(datos.pCompra,\ p) \hfill O(1)
\\
\tab \textbf{endif}
\\
\tab \textbf{if} $\neg$ esVacio?(w.promUlt) $\yluego$ siguiente(crearIt(w.promUlt))).cliente=c \hfill O(1)
\\
\tab \tab agregarRapido(siguiente(crearIt(w.promUlt))).promesas,\ p) \hfill O(1)
\\
\tab \textbf{endif}
\\
\textbf{Complejidad total}: O(log(C)+|nt|)
\\ \\
\NombreFuncion{iEnAlza}(\In{nt}{nombre},\In {w}{estr}) $\rightarrow$ (res:bool)
\\
\tab res $\leftarrow$ EnAlza(significado(nt, w.datosT\'{i}tulo)) \hfill O(|nt|)
\\ \\

\end{Algoritmos}


\section{M\'{o}dulo Diccionario\ Ordenado(clave, significado)}
\begin {Interfaz}
  \textbf{parametros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{generos}} $\kappa$, $\sigma$\\
  \parbox[t]{1.7cm}{\textbf{funcion}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{$\bullet$=$\bullet$}{\In{k1}{$\kappa$}, \In{k2}{$\kappa$}}{bool}
    {$res \igobs (c1=c2)$}
    [$\Theta(equal(c))$]
    [funcion de igualdad de $\kappa$'s]
  }
  \parbox[t]{1.7cm}{\textbf{funcion}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{c}{$\kappa$}}{$\kappa$}
    {$res \igobs c$}
    [$\Theta(copy(c))$]
    [funcion de copia de $\kappa$'s]
  }
  \parbox[t]{1.7cm}{\textbf{funcion}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{a}{$\sigma$}}{$\sigma$}
    {$res \igobs a$}
    [$\Theta(copy(s))$]
    [funcion de copia de $\sigma$'s]
  }
  \parbox[t]{1.7cm}{\textbf{funcion}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{$\bullet$<$\bullet$}{\In{c1}{$\kappa$} \In{c2}{$\kappa$}}{$\kappa$}
    {$res \igobs (c1<c2)$}
    [$\Theta(equal(c))$]
    [funcion de orden de $\kappa$'s]
  }
  \textbf{se explica con}: \tadNombre{Diccionario(clave, significado)}, modificado de la siguiente forma: \\

Observadores agregados: \\
\tab maxClaves: dicc(clave, significado) $\rightarrow$ nat \\
Generadores modificados: \\
\tab  vacio : nat $\rightarrow$ dicc(clave, significado) \\
\tab  definir : clave $\times$ significado $\times$ dicc(clave, significado) d $\rightarrow$ dicc(clave, significado) $\{ \#$(claves(d)) $\}$ \\
Nuevos axiomas: \\
\tab maxClaves(Vacio(n)) $\equiv$ n \\
\tab maxClaves(definir(c,s,d)) $\equiv$ maxClaves(d) \\

  
  \textbf{g\'{e}neros}: \TipoVariable{diccOrd}, \TipoVariable{itDiccOrd}

\tab El M\'{o}dulo Diccionario Ordenado provee un diccionario con una interfaz similar al diccionario lineal, es decir que muchas de sus operaciones b\'{a}sicas tienen los mismos argumentos de entrada y salida y cumplen los mismos Pre y Post. Se diferencian en las complejidades de las operaciones. Tiene tambi\'{e}n un m\'{a}ximo de claves que puede tener, que se especifica al crear el diccionario. Su iterador es unidireccional.\\
\\
  \tab \InterfazFuncion{Vacio}{\In{n}{nat}}{diccOrd($\kappa$, $\sigma$)}
  {res $\igobs$ vacio}
  [O(1)]
  [Crea un diccionario vacio cuyo maximo de claves es n]
\\ \\
  \tab \InterfazFuncion{definir}{\In{c}{$\kappa$},\ \In{s}{$\sigma$},\ \Inout{d}{diccOrd($\kappa$, $\sigma$)}}{itDiccOrd($\kappa$,\ $\sigma$)}
  [d $\igobs$ $d_0$ $\wedge \neg$ definido?(d, c) $\wedge$ $\#$claves(d) $\neq$ maxClaves(d)]
  {d $\igobs$ definir($d_0$; c; s) $\wedge$ haySiguiente(res) $\yluego$ Siguiente(res) = <c; s> $\wedge$ esPermutacion(SecuSuby(res),d)}
  [O($\#$claves(d) $\cdot$ (copy($\kappa$)+copy($\sigma$)))]
  [Define la clave c con el significado s en el diccionario]
  [Los elementos c y s se definen por copia. El iterador se invalida si y solo si se elimina el elemento siguiente
del iterador sin utilizar la funcion EliminarSiguiente. Ademas, siguientes(res) podria cambiar completamente ante cualquier operacion que modifique el d sin utilizar las funciones del iterador]
\\ \\
  \tab \InterfazFuncion{definirRapido}{\In{c}{$\kappa$},\ \In{s}{$\sigma$},\ \Inout{d}{diccOrd($\kappa$, $\sigma$)}}{itDiccOrd($\kappa$,\ $\sigma$)}
  [d $\igobs$ $d_0$ $\wedge \neg$ definido?(d, k) $\wedge (\forall$ c2 $\in$ claves(d)) c<c2  $\wedge$ $\#$claves(d) $\neq$ maxClaves(d)]
  {d $\igobs$ definir($d_0$; c; s) $\wedge$ haySiguiente(res) $\yluego$ Siguiente(res) = <c; s> $\wedge$ esPermutacion(SecuSuby(res),d)}
  [O(copy($\kappa$)+copy($\sigma$))]
  [Define la clave c con el significado s en el diccionario, requiere que c sea mayor a todo el resto de las claves del diccionario]
  [Los elementos c y s se definen por copia. El iterador se invalida si y solo si se elimina el elemento siguiente
del iterador sin utilizar la funcion EliminarSiguiente. Ademas, siguientes(res) podria cambiar completamente ante cualquier operacion que modifique el d sin utilizar las funciones del iterador]
\\ 
  \tab \InterfazFuncion{maxClaves}{\In{d}{diccOrd($\kappa$, $\sigma$)}}{nat}
  {d $\igobs$ maxClaves(d)}
  [O(1)]
  [Devuelve el maximo de claves del diccionario]
  \\
\tab \textbf{Las complejidades de las otras operaciones b\'{a}sicas son listadas a continuaci\'{o}n:} \\
\\
  \NombreFuncion{Definido?}(c,\ s,\ d): \tab O(log($\#$claves(d)) $\cdot$ equal($\kappa$)) 
\\
  \NombreFuncion{Significado}(c,\ d): \tab O(log($\#$claves(d)) $\cdot$ equal($\kappa$))
\\
  \NombreFuncion{Borrar}(c,\ d): \tab O($\#$claves(d) $\cdot$ (equal($\kappa$)+copy($\kappa$)+copy($\sigma$)))
\\
  \NombreFuncion{$\#$Claves}(d): \tab O(1)
\\
  \NombreFuncion{Copiar}(d): \tab O($\#$claves(d) $\cdot$ (copy($\kappa$)+copy($\sigma$)))
\\
  \NombreFuncion{d1=d2}: \tab O($\#$claves(d) $\cdot$ (copy($\kappa$)+copy($\sigma$)))
\\
\tab \textbf{Las operaciones del iterador definidas son las siguientes, con su complejidad:} \\
\\
  \NombreFuncion{crearIt(d)}: \tab O(1)
\\
  \NombreFuncion{haySiguiente(d)}: \tab O(1)
\\
  \NombreFuncion{siguiente(d)}: \tab O(1)
\\
  \NombreFuncion{siguienteClave(d)}: \tab O(1)
\\
  \NombreFuncion{siguienteSignificado(d)}: \tab O(1)
\\
  \NombreFuncion{avanzar(d)}: \tab O(1)


\end {Interfaz}

\begin{Representacion}
  
  \Title{Representaci\'{o}n del diccionario}

  \begin{Estructura}{diccOrd($\kappa$, $\sigma$)}[diccord]
    donde \TipoVariable{diccOrd} es tupla<elementos:array(tupla<$\kappa$,\ $\sigma$>), longitud:nat, lReal:nat>
  \end{Estructura}
  

  \Rep[$\sombrero{estr}$][d]{ ($\forall$ i,j:nat) (i<d.lReal $\wedge$ j<d.lReal) $\impluego$ ($\Pi_1$ d.elementos[i] $\neq \Pi_1$ d.elementos[j] $\wedge$ i<j $\Leftrightarrow \Pi_1$ d.elementos[i]< $\Pi_1$ d.elementos[j]) \\ $\wedge$ d.lReal $\leq$ d.longitud \\ $\wedge (\forall$i: nat)(0 $\leq$ i < d.longitud $\impluego$ def?(v.elementos, i)}\mbox{}
 
   Abs : estr d $\rightarrow$ dicc($\kappa$,\ $\sigma$) \hfill $\{$ Rep(d)$\}$ \\
Abs(d) $\igobs$ d2: dicc($\kappa$,\ $\sigma$) | ($\forall$ c:$\kappa$) def?(c,\ d2)=($\exists$ s:$\sigma$, i:nat) d.elementos[i]=<c, s>) $\yluego (\forall$ c:$\kappa$) obtener(c, d2)=$\Pi_2$ (d.elementos[buscarIndice(d,\ c,\ 0)])
  
\NombreFuncion(buscarIndice) (estr, $\kappa$, nat) $\rightarrow$ nat
buscarIndice(e,\ c,\ i)= \textbf{if} $\Pi_1$ e[i]=c \textbf{then} i \textbf{else} buscarIndice(e,\ c,\ i+1) \textbf{fi}

  \Title{Representaci\'{o}n del iterador}

  \begin{Estructura}{itDiccOrd($\kappa$, $\sigma$)}[itDiccOrd]
	donde \TipoVariable{itDiccOrd} es tupla<elementos: array(<tupla($\kappa$),\ ($\sigma$)>$\ast$, i:nat, long:nat>)
  \end{Estructura}

\Rep[$\sombrero{iter}$][id]{($\forall$ i, j:nat) (i<id.long $\wedge$ j<id.long) $\impluego$ i<j $\leftrightarrow$ $\Pi_1$(id.elementos$\ast$)[i] $\leq \Pi_1$(id.elementos$\ast$)[j] \\ $\wedge$ id.i < id.long}\mbox{}
 
Abs : iter it $\rightarrow$ itUni($\alpha$) \hfill $\{$ Rep(it)$\}$ \\
Abs(it) $\igobs$ b: itUni($\alpha$) | Siguientes(b) = Abs(subArreglo(it.elementos$\ast$, it.i, it.long))
	
\end{Representacion}

\begin{Algoritmos}

  \NombreFuncion{iVacio} (n:nat) $\rightarrow$ res:estr
\\
	\tab res.elementos $\leftarrow$ a[n] \hfill O(1)
\\
	\tab res.lReal $\leftarrow$ 0  \hfill O(1)
\\
	\tab res.longitud $\leftarrow$ n \hfill O(1)
\\ \\
  \NombreFuncion{iDefinir} (\Inout{d}{diccOrd($\kappa$, $\sigma$)}, \In{c}{$\kappa$}, \In{s}{$\sigma$}) $\rightarrow$ res:itDiccOrd($\kappa$, $\sigma$)
\\
	\tab i $\leftarrow$ 0 \hfill O(1)
\\
	\tab \textbf{while} i<d.lReal \hfill O(1)
\\
	\tab \tab \textbf{if} $\Pi_1$(d.elementos[i]) > c \hfill O(1)
\\
	\tab \tab \tab <a, b> $\leftarrow$ copy(d.elementos[i]) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab \tab \tab d.elementos[i] $\leftarrow$ copy(<c,s>) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab \tab \tab <c, s> $\leftarrow$ copy(<a, b>) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab \tab \textbf{endif}	
\\
	\tab \tab i $\leftarrow$ i+1 \hfill O(1)
\\
	\tab \textbf{endwhile} \hfill O(d.lreal $\cdot$ (copy($\kappa$)+copy($\sigma$)))
\\
	\tab d.elementos[i] $\leftarrow$ copy(<c, s>) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab d.lReal $\leftarrow$ d.lReal+1 \hfill O(1)
\\
	\tab res $\leftarrow$ crearIt(d)
\\ \\
  \NombreFuncion{iDefinirRapido} (\Inout{d}{diccOrd($\kappa$, $\sigma$)}, \In{c}{$\kappa$}, \In{s}{$\sigma$})  $\rightarrow$ res:itDiccOrd($\kappa$, $\sigma$)
\\
	\tab d.lReal $\leftarrow$ d.lReal+1 \hfill O(1)
\\
	\tab d.elementos[lReal+1] $\leftarrow$ copy(<c, s>) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab res $\leftarrow$ crearIt(d)
\\ \\
  \NombreFuncion{iDefinido?} (\In {d}{diccOrd} \In{c}{$\kappa$}) $\rightarrow$ res:bool
\\
	\tab i $\leftarrow$ (d.lReal)/2 \hfill O(1)
\\
	\tab max $\leftarrow$ d.lReal \hfill O(1)
\\
	\tab min $\leftarrow$ 0 \hfill O(1)
\\
	\tab res $\leftarrow$ false \hfill O(1)
\\
	\tab \textbf {while} max $\neq$ min $\wedge$ max $\neq$ min+1 $\wedge$ res=false \hfill O(1)
\\
	\tab \tab \textbf{if} $\Pi_1$ d.elementos[i]=c \hfill O(equal($\kappa$))
\\
	\tab \tab \tab res $\leftarrow$ true \hfill O(1)
\\
	\tab \tab \textbf{else if} $\Pi_1$ d.elementos[i]<c \hfill O(equal($\kappa$))
\\
	\tab \tab \tab min $\leftarrow$ i \hfill O(1)
\\
	\tab \tab \tab i $\leftarrow$ (i+max)/2 \hfill O(1)
\\
	\tab \tab \textbf{else} \hfill O(1)
\\
	\tab \tab \tab max $\leftarrow$ i \hfill O(1)
\\
	\tab \tab \tab i $\leftarrow$ (i+min)/2 \hfill O(1)
\\
	\tab \tab \textbf{endif}
\\
	\tab \textbf{endwhile} \hfill O(log($\#$claves(d)) $\cdot$ equal($\kappa$))
\\ \\
  \NombreFuncion{iSignificado} (\In {d}{diccOrd} \In{c}{$\kappa$}) $\rightarrow$ res:$\sigma$
\\
	\tab i $\leftarrow$ (d.lReal)/2 \hfill O(1)
\\
	\tab max $\leftarrow$ d.lReal \hfill O(1)
\\
	\tab min $\leftarrow$ 0 \hfill O(1)
\\
	\tab encontrado $\leftarrow$ false \hfill O(1)
\\
	\tab \textbf{while} $\neg$ encontrado \hfill O(1)
\\
	\tab \tab \textbf{if} $\Pi_1$ d.elementos[i]=c \hfill O(equal($\kappa$))
\\
	\tab \tab \tab res $\leftarrow$ $\Pi_1$ d.elementos[i] \hfill O(equal($\kappa$))
\\
	\tab \tab \tab encontrado $\leftarrow$ true \hfill O(1)
\\
	\tab \tab \textbf {else if} $\Pi_1$ d.elementos[i]<c \hfill O(equal($\kappa$))
\\
	\tab \tab \tab min $\leftarrow$ i \hfill O(1)
\\
	\tab \tab \tab i $\leftarrow$ (i+max)/2 \hfill O(1)
\\
	\tab \tab \textbf {else} \hfill O(1)
\\
	\tab \tab \tab max $\leftarrow$ i \hfill O(1)
\\
	\tab \tab \tab i $\leftarrow$ (i+min)/2 \hfill O(1)
\\
	\tab \tab \textbf{endif}
\\
	\tab \textbf{endwhile} \hfill O(log($\#$claves(d)) $\cdot$ equal($\kappa$))
\\ \\
  \NombreFuncion{iBorrar(\Inout{d}{diccOrd}, \In{c}{$\kappa$})}
\\
	\tab i $\leftarrow$ 0 \hfill O(1)
\\
	\tab encontrado $\leftarrow$ false  \hfill O(1)
\\
	\tab \textbf{while} i<(d.lReal-1) \hfill O(1)
\\
	\tab \tab \textbf{if} $\Pi_1$(d.elementos[i]) = c $\wedge$ encontrado=true \hfill O(equal($\kappa$))
\\
	\tab \tab \tab d.elementos[i] $\leftarrow$ copy(d.elementos[i+1]) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab \tab \tab encontrado $\leftarrow$ true \hfill O(1)
\\
	\tab \tab \textbf{endif}
\\
	\tab \tab i $\leftarrow$ i+1 \hfill O(1)
\\
	\tab \textbf{endwhile} \hfill O(d.lReal $\cdot$ (equal($\kappa$)+copy($\kappa$)+copy($\kappa$)))
\\
	\tab d.lReal $\leftarrow$ d.lReal-1 \hfill O(1)
\\ \\
  \NombreFuncion{i$\#$Claves} (\In{d}{diccOrd}) $\rightarrow$ res:nat
\\
	\tab res $\leftarrow$ d.lReal \hfill O(1)
\\ \\
  \NombreFuncion{$\bullet$=$\bullet$} (\In{d1}{diccOrd($\kappa$, $\sigma$)}, \In{d2}{diccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:bool
\\
	\tab i $\leftarrow$ 0 \hfill O(1)
\\
	\tab res $\leftarrow$ true  \hfill O(1)
\\
	\tab \textbf{if} (d1.lreal $\neq$ d2.lReal) \hfill O(1)
\\
	\tab \tab res $\leftarrow$ false \hfill O(1)
\\
	\tab \textbf{else}
\\
	\tab \tab \textbf{while} i<d1.lReal \hfill O(1)
\\
	\tab \tab \tab \textbf{if} d1[i] = d2[i] \hfill O(equal($\kappa$)+equal($\sigma$))
\\
	\tab \tab \tab \tab res $\leftarrow$ false \hfill O(1)
\\
	\tab \tab \tab \textbf{endif}	
\\
	\tab \tab \tab i $\leftarrow$ i+1 \hfill O(1)
\\
	\tab \tab \textbf{endwhile} \hfill O(d1.lReal $\cdot$ (equal($\kappa$)+equal($\sigma$)))
\\
	\tab \textbf{endif}
\\ \\
  \NombreFuncion{iCrearIt} (\In{d}{DiccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:itDiccOrd($\kappa$, $\sigma$)
\\
	\tab res.i $\leftarrow$ 0 \hfill O(1)
\\
	\tab res.long $\leftarrow$ d.lReal \hfill O(1)
\\
	\tab res.elementos $\leftarrow \ast$(d.elementos) \hfill O(1)
\\ \\
  \NombreFuncion{iHaySiguiente} (\In{d}{itDiccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:bool
\\
	\tab res $\leftarrow$ d.i<d.long \hfill O(1)
\\ \\
  \NombreFuncion{isiguienteClave} (\In{d}{itDiccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:$\kappa$
\\
	\tab res $\leftarrow \Pi_1(\ast$d.elementos) \hfill O(1)
\\ \\
  \NombreFuncion{isiguienteSignificado} (\In{d}{itDiccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:$\sigma$
\\
	\tab res $\leftarrow \Pi_2(\ast$d.elementos)  \hfill O(1)
\\ \\
  \NombreFuncion{iSiguiente} (\In{d}{itDiccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:tupla<$\kappa$, $\sigma$>
\\
	\tab res $\leftarrow \ast$ d.elementos  \hfill O(1)
\\ \\
  \NombreFuncion{iAvanzar} (\Inout{d}{itDiccOrd($\kappa$, $\sigma$)})
\\
	\tab d.i $\leftarrow$ (d.i)+1  \hfill O(1)
\\
	\tab d.elementos $\leftarrow$ (d.elementos)+1  \hfill O(1)
\\ \\

\end{Algoritmos}

\section{M\'{o}dulo Diccionario Texto(string,\ tupla($\alpha$, $\beta$, $\gamma$))}
\begin {Interfaz}
  \textbf{se explica con}: \tadNombre{DiccionarioEterno}.
  
  \textbf{g\'{e}neros}: \TipoVariable{diccT(string,\ tupla($\alpha$, $\beta$, $\gamma$))}

\tab El M\'{o}dulo Diccionario Texto provee un diccionario con la misma interfaz que la del Diccionario Lineal, salvo borrar, $\#$Claves, copiar y comparaci\'{o}n(es decir que sus operaciones b\'{a}sicas tienen los mismos nombres, mismos argumentos de entrada y salida y cumplen los mismos Pre y Post, salvo borrar que no est\'{a} disponible) y las operaciones tienen distintas complejidades.\\
\tab Adem\'{a}s hicimos que se explique con el TAD DiccionarioEterno que tiene los mismos generadores, observadores y otras Operaciones que las del TAD Diccionario($\kappa$,\ $\sigma$) (con la misma axiomatizaci\'{o}n) exceptuando borrar, que no est\'{a} en DiccionarioEterno. Consideramos que todos los significados de DiccionarioEterno son tupla($\alpha$, $\beta$, $\gamma$) y que las claves son strings.\\ 
\tab el iterador devuelve elementos de tipo $\alpha$ al aplicar siguiente, no tuplas.
\\
\tab \textbf{Las complejidades de las operaciones b\'{a}sicas son listadas a continuaci\'{o}n:} \\

  \NombreFuncion{Vacio()}{}: \tab O(1)
\\
  \NombreFuncion{Definir(s:string,\ tupla($\alpha$, $\beta$, $\gamma$),\ d:diccT(string,\ tupla($\alpha$, $\beta$, $\gamma$)))}: \tab O(long(s))
\\
  \NombreFuncion{Definido?(s:string,\ d:diccT(string,\ tupla($\alpha$, $\beta$, $\gamma$)))}: \tab O(long(s))
\\
  \NombreFuncion{Significado(s:string,\ d:diccT(string,\ tupla($\alpha$, $\beta$, $\gamma$)))}: \tab O(long(s))
\\
\tab \textbf{Las complejidades de las operaciones del iterador son las siguientes:} \\
\\
  \NombreFuncion{CrearIt(d:diccT(string,\ tupla($\alpha$, $\beta$, $\gamma$)))}: \tab O(1)
\\  
  \NombreFuncion{Avanzar(id:itdiccT(string,\ tupla($\alpha$, $\beta$, $\gamma$)))}: \tab O(1)
\\	
  \NombreFuncion{SiguienteClave(id:itdiccT(string,\ tupla($\alpha$, $\beta$, $\gamma$)))}: \tab O(1)
\\	
  \NombreFuncion{SiguienteSignificado(id:itdiccT(string,\ tupla($\alpha$, $\beta$, $\gamma$)))}: \tab O(long(SiguienteClave(id)))
\\	
  \NombreFuncion{Siguiente(id:itdiccT(string,\ tupla($\alpha$, $\beta$, $\gamma$)))}: \tab O(long(SiguienteClave(id)))
\\	
  \NombreFuncion{HaySiguiente(id:itdiccT(string,\ tupla($\alpha$, $\beta$, $\gamma$)))}: \tab O(long(SiguienteClave(id)))


\end {Interfaz}

\begin{Representacion}
	\Title{Representaci\'{o}n del Diccionario Texto}

	\begin{Estructura}{DiccT}[dicct]
		tupla(primVec:vectorDe256Punteros(ptro(vectorDe256Punteros)),\\
		\tab claves:conj(string)) 
  	\end{Estructura}

      \Rep[dicct][d]{\textbf{1)} ($\forall$ s:string) (pertenece?(s, claves(d))) $\leftrightarrow$ (definido?(s,d))}\mbox{}
	\textbf{1)} Todos los elementos de claves están definidos y viceversa.
	\textbf{2)} Los punteros no forman ciclos (Para todos los caminos posibles de punteros en ningún momento se puede recorrer dos veces al mismo)
	
		Abs:dicct d $\rightarrow$ diccionarioEterno \hfill $\{$ Rep(d) $\}$ \\
	Abs(d)$\igobs$ d2:dicct|($\forall$ s: string) (Definido?(s,d)) $\leftrightarrow$ (Definido?(s,d2))\\ $\wedge$
	($\forall$ s:string) (Definido?(s,d)) $\impluego$ (Significado(s,d) = Significado(s,d2))
	
	\Title{Representaci\'{o}n del iterador}

	\begin{Estructura}{ItDiccT}[itdicct]
		tupla(punt: $\ast$(dicct), itClaves:itConj(string))
   \end{Estructura}
   \end{Representacion}
   \textbf{Descripcion del Rep:}
	\\ \\
	  \Rep[itdicct][d]{Rep($\ast$punt) $\wedge$ d.itClaves=claves($\ast$punt)}
	  \mbox{}

	Abs:itdicct d $\rightarrow$ itUni($\alpha$) \hfill $\{$ Rep(d) $\}$ \\
	Abs(d)$\igobs$ d2:itUni($\alpha$)| Siguientes(d2) = (significados($\ast$d.elementos, siguientes(crearIt(d.claves))))
  
  \NombreFuncion{significados} (dicct, conj(claves)) $\rightarrow$ conj($\alpha$)
  significados(d, cs) = $\bigcup_{c \in cs} \Pi_1$(significado(c,d)) \\
	\begin{Algoritmos}
	\NombreFuncion{Vacio}() $\rightarrow$ res:diccT(string,\ tupla($\alpha$, $\beta$, $\gamma$))
\\
\tab	res\ $\leftarrow$ tupla(<NULL,NULL,...,NULL>,\ Vacio())	\hfill O(1)
\\ \\
	\NombreFuncion{Definir}(\In{s}{string},\ \In{sig}{tupla($\alpha$, $\beta$, $\gamma$)},\ \Inout{d}{diccT(string,\ tupla($\alpha$, $\beta$, $\gamma$)))})
\\
\tab	i\ $\leftarrow$ 1 \hfill O(1)
\\
\tab	paux\ $\leftarrow$ d.primVec[ord(s[0])]  \hfill O(1)
\\
\tab	\textbf{while} (i<Longitud(s))  \hfill O(1)
\\
\tab \tab \textbf{if} ($\ast$paux[ord(s[0])])=NULL \hfill O(1)
\\
\tab \tab \tab nuevoVec $\leftarrow$ tupla(<NULL, NULL,...,NULL>,NULL)
\\
\tab \tab \tab ($\ast$paux)[ord(s[i])]=$\&$nuevoVec
\\
\tab \tab \textbf {endif}
\\
\tab \tab paux.sign $\leftarrow$ sig
\\
\tab \tab	i\ =\ i\ +\ 1  \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O(Longitud(s))
\\
\tab res $\leftarrow (\ast$pAux).sign \hfill O(1)
\\
\tab agregarRapido (d.claves, s) \hfill O(long(s))
\\ \\
	\NombreFuncion{Definido?}(\In{s}{string} ,\In{d}{dicct(string,\ tupla($\alpha$, $\beta$, $\gamma$)))}) $\leftarrow$ res:bool
\\
\tab res $\leftarrow$ true \hfill O(1)
\\
\tab \textbf{if} d.primVec[ord([s(0)])]=NULL \hfill O(1)
\\
\tab \tab res $\leftarrow$ false \hfill O(1)
\\
\tab \textbf{endif} \hfill O(1)
\\
\tab i\ $\leftarrow$ 1 \hfill O(1)
\\
\tab paux\ $\leftarrow$ d.primVec[ord(s[0])] \hfill O(1)
\\
\tab \textbf{while}(i<Longitud(s)) \hfill O(1)
\\
\tab paux\ $\leftarrow$ paux[ord(s[i])] \hfill O(1)
\\
\tab \tab \textbf{if} $\ast$ paux [ord(s[i])]=NULL \hfill O(1)
\\
\tab \tab \tab res $\leftarrow$ false \hfill O(1)
\\
\tab \tab \textbf{endif} \hfill O(1)
\\
\tab \tab	i\ =\ i\ +\ 1 \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O(longitud(s))
\\
\tab res $\leftarrow (\ast$pAux).sign \hfill O(1)
\\ \\
\NombreFuncion{Significado}(\In{s}{string},\ \In{d}{dicct(string,\ tupla($\alpha$, $\beta$, $\gamma$)))}) $\leftarrow$ res:tupla($\alpha$, $\beta$, $\gamma$)
\\
\tab i $\leftarrow$	1 \hfill O(1)
\\
\tab paux $\leftarrow$ d.primVec[ord(s[0])] \hfill O(1)
\\
\tab (i<longitud(s)) \hfill O(1)
\\
\tab \textbf{while} i<longitud(s) \hfill O(1)
\\
\tab \tab paux $\leftarrow$ (paux.VecPunteros[ord(s[i])])  \hfill O(1)
\\
\tab \tab i $\leftarrow$ i+1  \hfill O(1)
\\
\tab \textbf{endwhile}  \hfill O(longitud(s))
\\
\tab res $\leftarrow(\ast$Paux).sign \hfill O(1)
\\ \\
\NombreFuncion{CrearIt} (\In{d}{dicct(string,\ tupla($\alpha$,\ $\beta$, $\gamma$))}) $\rightarrow$ res: itDiccT(string,\ tupla($\alpha$, $\beta$, $\gamma$))
\\
\tab res.punt $\leftarrow \&$ d \hfill O(1)
\\
\tab res.itClaves $\leftarrow$ crearIt(d.claves) \hfill O(1)
\\ \\
\NombreFuncion{avanzar} (\Inout{d}{dicct(string,\ tupla($\alpha$,\ $\beta$, $\gamma$))})
\\
\tab avanzar (d.itClaves) \hfill O(1)
\\ \\
\NombreFuncion{SiguienteClave} (\In{d}{dicct(string,\ tupla($\alpha$,\ $\beta$, $\gamma$))}) $\rightarrow$ res:string
\\
\tab res $\leftarrow$ siguiente(d.itClaves) \hfill O(1)
\\ \\
\NombreFuncion{SiguienteSignificado} (\In{d}{dicct(string,\ tupla($\alpha$,\ $\beta$, $\gamma$))}) $\rightarrow$ res:tupla($\alpha$,\ $\beta$, $\gamma$))
\\
\tab res $\leftarrow$ significado(($\ast$(d.punt)),siguiente(res.claves)) \hfill O(longitud(siguiente(res.claves)))
\\ \\
\NombreFuncion{siguiente} (\In{d}{dicct(string,\ tupla($\alpha$,\ $\beta$, $\gamma$))}) $\rightarrow$ res:$\alpha$
\\
\tab res $\leftarrow$ $\Pi_1$(significado(($\ast$(d.punt) ),siguiente(res.claves))) \hfill O(longitud(siguiente(res.claves)))
\\ \\
\NombreFuncion{HaySiguiente} (\In{d}{dicct(string,\ tupla($\alpha$,\ $\beta$, $\gamma$))}) $\rightarrow$ res:bool
\\
\tab res $\leftarrow$ haySiguiente(d.claves) \hfill O(1)
\end{Algoritmos}

\newpage
\section{Informe}
\subsection{Decisiones Tomadas}
\textbf{1:}\tab Decidimos llamar al Diccionario Ordenado debido a que el iterador devuelve de manera ordenada sus tuplas, por lo tanto no hay problemas de encapsulamiento.
\subsection{Soluciones alternativas}
Para poder usar un tipo $\sigma$ general en lugar de una tupla <$\alpha$, $\beta$, $\gamma$>\ en el diccionario de texto, se podria modificar la estructura de forma que incluya dos de estos diccionarios: uno cuyo significado sean titulos y otro cuyo significado sea el resto de los datos necesarios. De esta forma, el iterador podr\'{i}a devolver elementos de tipo $\sigma$, no buscar el primer elemento de la tupla, y se seguir\'{i}an cumpliendo las complejidades. \\
En la estructura preferimos usar conjuntos de hasta una promesa a usar un puntero a promesa que se har\'{i}a NULL si no hubiera ninguna.

\end{document}


