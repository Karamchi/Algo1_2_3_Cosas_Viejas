\documentclass[10pt, a4paper]{article}
\usepackage[paper=a4paper, left=1.5cm, right=1.5cm,hmargin=1.5cm, bottom=1.5cm, top=3.5cm]{geometry}
\usepackage[latin1]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[spanish]{babel}
\usepackage{indentfirst}
\usepackage{fancyhdr}
\usepackage{latexsym}
\usepackage{lastpage}
\usepackage{aed2-symb,aed2-itef,aed2-tad}
\usepackage[colorlinks=true, linkcolor=blue]{hyperref}
\usepackage{calc}
\usepackage[conEntregas]{caratula}
\usepackage{xspace}
\usepackage{xargs}
\usepackage{ifthen}
\usepackage{aed2-tad,aed2-symb,aed2-itef}

\newcommand{\moduloNombre}[1]{\textbf{#1}}

\let\NombreFuncion=\textsc
\let\TipoVariable=\texttt
\let\ModificadorArgumento=\textbf
\newcommand{\res}{$res$\xspace}
\newcommand{\tab}{\hspace*{7mm}}

\newcommandx{\TipoFuncion}[3]{%
  \NombreFuncion{#1}(#2) \ifx#3\empty\else $\to$ \res\,: \TipoVariable{#3}\fi%
}
\newcommand{\In}[2]{\ModificadorArgumento{in} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Out}[2]{\ModificadorArgumento{out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Inout}[2]{\ModificadorArgumento{in/out} \ensuremath{#1}\,: \TipoVariable{#2}\xspace}
\newcommand{\Aplicar}[2]{\NombreFuncion{#1}(#2)}
\newcommand{\sombrero}[1]{\widehat{#1}}


\newlength{\IntFuncionLengthA}
\newlength{\IntFuncionLengthB}
\newlength{\IntFuncionLengthC}
%InterfazFuncion(nombre, argumentos, valor retorno, precondicion, postcondicion, complejidad, descripcion, aliasing)
\newcommandx{\InterfazFuncion}[9][4=true,6,7,8,9]{%
  \hangindent=\parindent
  \TipoFuncion{#1}{#2}{#3}\\%
  \textbf{Pre} $\equiv$ \{#4\}\\%
  \textbf{Post} $\equiv$ \{#5\}%
  \ifx#6\empty\else\\\textbf{Complejidad:} #6\fi%
  \ifx#7\empty\else\\\textbf{Descripci\'{o}n:} #7\fi%
  \ifx#8\empty\else\\\textbf{Aliasing:} #8\fi%
  \ifx#9\empty\else\\\textbf{Requiere:} #9\fi%
}

\newenvironment{Interfaz}{%
  \parskip=2ex%
  \noindent\textbf{\Large Interfaz}%
  \par%
}{}

\newenvironment{Representacion}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Representaci\'{o}n}%
  \vspace*{2ex}%
}{}

\newenvironment{Algoritmos}{%
  \vspace*{2ex}%
  \noindent\textbf{\Large Algoritmos}%
  \vspace*{2ex}%
}{}


\newcommand{\Title}[1]{
  \vspace*{1ex}\par\noindent\textbf{\large #1}\par
}

\newenvironmentx{Estructura}[2][2={estr}]{%
  \par\vspace*{2ex}%
  \TipoVariable{#1} \textbf{se representa con} \TipoVariable{#2}%
  \par\vspace*{1ex}%
}{%
  \par\vspace*{2ex}%
}%

\newboolean{EstructuraHayItems}
\newlength{\lenTupla}
\newenvironmentx{Tupla}[1][1={estr}]{%
    \settowidth{\lenTupla}{\hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($}%
    \addtolength{\lenTupla}{\parindent}%
    \hspace*{3mm}donde \TipoVariable{#1} es \TipoVariable{tupla}$($%
    \begin{minipage}[t]{\linewidth-\lenTupla}%
    \setboolean{EstructuraHayItems}{false}%
}{%
    $)$%
    \end{minipage}
}

\newcommandx{\tupItem}[3][1={\ }]{%
    %\hspace*{3mm}%
    \ifthenelse{\boolean{EstructuraHayItems}}{%
        ,#1%
    }{}%
    \emph{#2}: \TipoVariable{#3}%
    \setboolean{EstructuraHayItems}{true}%
}

\newcommandx{\RepFc}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{#3}%
}%

\newcommandx{\Rep}[3][1={estr},2={e}]{%
  \tadOperacion{Rep}{#1}{bool}{}%
  \tadAxioma{Rep($#2$)}{true \ssi #3}%
}%

\newcommandx{\Abs}[5][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \settominwidth{\hangindent}{Abs($#3$) \igobs #4: #2 $\mid$ }%
  \addtolength{\hangindent}{\parindent}%
  Abs($#3$) \igobs #4: #2 $\mid$ #5%
}%

\newcommandx{\AbsFc}[4][1={estr},3={e}]{%
  \tadOperacion{Abs}{#1/#3}{#2}{Rep($#3$)}%
  \tadAxioma{Abs($#3$)}{#4}%
}%


\newcommand{\DRef}{\ensuremath{\rightarrow}}

\begin{document}

\titulo{Trabajo Pr\'{a}ctico}
\subtitulo{}

\fecha{\today}

\materia{Algoritmos y Estructura de Datos II}
\grupo{Grupo 13}

\integrante{Fosco, Martin Esteban}{449/13}{mfosco2005@yahoo.com.ar}
\integrante{Minces M\"{u}ller, Javier Nicol\'{a}s}{231/13}{javijavi1994@gmail.com}
\integrante{Murga, Christian Mariano}{982/12}{christian.murga@underverse.com.ar}
\integrante{Palladino, Julian Alberto}{336/13}{julianpalladino@hotmail.com}
% Pongan cuantos integrantes quieran

\maketitle

\section{M\'{o}dulo Promesa}
\begin{Interfaz}
  \textbf{se explica con}: \tadNombre{Promesa}.\\

  \textbf{g\'{e}neros}: \TipoVariable{promesa}.\\
 \Title{Operaciones}
  \InterfazFuncion{t\'{i}tulo} {\In{p}{promesa}}{nombre}
  {$res \igobs titulo(p)$}
  [$O(1)$]
  [Devuelve el nombre del t\'{i}tulo sobre el que se hizo la promesa]
  [?]
  
  \InterfazFuncion{tipo} {\In{p}{promesa}}{tipoPromesa}
  {$res \igobs tipo(p)$}
  [$O(1)$]
  [Devuelve 'comprar' si la promesa es de compra y "vender" si no lo es]
  [?]
  
  \InterfazFuncion{limite} {\In{p}{promesa}}{dinero}
  {$res \igobs limite(p)$}
  [$O(1)$]
  [Devuelve el valor que la cotizaci\'{o}n tiene que superar para que se ejecute una promesa.]
  
  \InterfazFuncion{cantidad} {\In{p}{promesa}}{nat}
  {$res \igobs cantidad(p)$}
  [$O(1)$]
  [Devuelve la cantidad de acciones que se compran o se venden cuando la promesa se ejecuta]
  
  \InterfazFuncion{crearPromesa} {\In{n}{nombre},\ \In{t}{tipo},\ \In{l}{dinero},\ \In{c}{nat}}{promesa}
  {$res \igobs crearpromesa(n,t,l,c)$}
  [$O(1)$]
  [Si t es 'comprar', devuelve una promesa de comprar c acciones de n si su coitzaci\'{o}n supera l. Si t es "vender", devuelve una promesa de vender c acciones de n si su cotizaci\'{o}n daja de l]
  [nombre y tipo son modificables si y solo si la promesa es modificable]
  
    \InterfazFuncion{promesaEjecutable} {\In{p}{promesa},\ \In{d}{dinero},\ \In{n}{nat}}{bool}
  {$res \igobs promesaEjecutable(p,d,n)$}
  [$O(1)$]
  [Si la promesa es de compra, devuelve true si y solo si la cotizaci\'{o}n del t\'{i}tulo de la promesa super\'{o} el l\'{i}mite y hay suficientes disponibles. Si la promesa es de venta, devuelve true si y solo si la cotizaci\'{o}n del t\'{i}tulo baj\'{o} del l\'{i}mite.]
  
   \InterfazFuncion{compraVenta} {\In{d}{nat},\ \In{ps}{conj(promesa)}}{nat}
  {$res \igobs compraVenta(d,ps)$}
  [$O($\#$(ps))$]
  [Devuelve la disponiblidad m\'{a}s la suma de cantidades de las promesas de compra de un conjunto, menos la suma de las cantidades de las promesas de venta de dicho conjunto.]
  
  \InterfazFuncion{promesasSobreTitulo} {\In{n}{nombre},\ \In{t}{tipoPromesa},\ \In{ps}{conj(promesa)}}{conj(promesa)}
  {$res \igobs promesasSobreTitulo(n,t,ps)$}
  [$O($\#$(ps))$]
  [Devuelve, de un conjunto de promesas, aquellas que son de un determinado tipo y titulo.]
  [?]
  
\end{Interfaz}
\begin{Representacion}
    \begin{Estructura}{promesa}[estr]
    \begin{Tupla}[promesa] 
      \tupItem{t\'{i}tulo}{nombre}
      \tupItem{tipo}{tipoPromesa}
      \tupItem{cantidad}{acciones}
      \tupItem{l\'{i}mite}{nat}
    \end{Tupla} 
    \end{Estructura}
      \Rep[estr][p]{true}\mbox{}
      \AbsFc[estr]{promesa}[p]{titulo(p)=p.titulo\\$\wedge$ tipo(p)=p.tipo \\$\wedge$ cantidad(p)=p.cantidad\\$\wedge$ l\'{i}mite(p)=p.l\'{i}mite}
      
\end{Representacion}
\begin{Algoritmos}
\\
(Las complejidades junto a una asignacion representan el costo de evaluar y asignar. Las complejidades junto a un \textbf {if} o un \textbf{while} representan el costo de evaluar la guarda. Las complejidades junto a un \textbf{endwhile} representan el costo de todo el ciclo.)
\\
\NombreFuncion{iTitulo}(\In{p}{estr}) $\rightarrow$ res:nombre
\\
\tab res $\leftarrow$ p.titulo \hfill O(1)
\\
\NombreFuncion{iTipo}(\In{p}{estr}) $\rightarrow$ res:tipoPromesa
\\
\tab res $\leftarrow$ p.tipo \hfill O(1)
\\
\NombreFuncion{iLimite}(\In{p}{estr}) $\rightarrow$ res:dinero
\\
\tab res $\leftarrow$ p.limite \hfill O(1)
\\
\NombreFuncion{iCantidad}(\In{p}{estr}) $\rightarrow$ res:nat
\\
\tab res $\leftarrow$ p.cantidad \hfill O(1)
\\
\NombreFuncion{iCrearPromesa}(\In{n}{nombre},\ \In{t}{tipo},\ \In{l}{dinero},\ \In{c}{nat}) $\rightarrow$ res:estr
\\
\tab res.nombre $\leftarrow$ n \hfill O(1)
\\
\tab res.tipo $\leftarrow$ t \hfill O(1)
\\
\tab res.limite $\leftarrow$ l \hfill O(1)
\\
\tab res.cantidad $\leftarrow$ c \hfill O(1)
\\
\NombreFuncion{iPromesaEjecutable}(\In{p}{promesa},\ \In{d}{dinero},\ \In{n}{nat}) $\rightarrow$ res:bool
\\
\tab res $\leftarrow$ tipo(p)=venta $\wedge$ d < l\'{i}mite(p)) $\vee$
tipo(p) = compra $\wedge$ d > limite(p) $\wedge$ n $\geq$ cantidad(p) \hfill O(1)
\\
\NombreFuncion{iCompraVenta}(\In{d}{nat},\ \In{p}{conj(promesa)}) $\rightarrow$ res:nat
\\
\tab res $\leftarrow$ d \hfill O(1)
\\
\tab ps $\leftarrow$ crearIt(p) \hfill O(1)
\\
\tab \textbf{while} (hayMas?(ps)) \hfill O(1)
\\
\tab \tab \textbf{if} siguiente(ps).tipo=comprar \hfill O(1)
\\
\tab \tab \tab res $\leftarrow$ res+siguiente(ps).cantidad \hfill O(1)
\\
\tab \tab \textbf{else}
\\
\tab \tab \tab res $\leftarrow$ res-siguiente(ps).cantidad \hfill O(1)
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(ps) \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O($\#$(p))
\\
\NombreFuncion{iPromesasSobreTitulo}(\In{n}{nombre},\ \In{t}{tipoPromesa},\ \In{p}{conj(promesa)}) $\rightarrow$ res:conj(promesa)
\\
\tab res $\leftarrow$ Vacio() \hfill O(1)
\\
\tab ps $\leftarrow$ crearIt(p) \hfill O(1)
\\
\tab \textbf{while} (hayMas?(ps)) \hfill O(1)
\\
\tab \tab \textbf{if} siguiente(ps).tipo=t $\wedge$ siguiente(ps).titulo=n \hfill O(1)
\\
\tab \tab \tab AgregarRapido(res,\ siguiente(ps)) \hfill O(1)
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(ps) \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O($\#$(p))
\\
\end{Algoritmos}

\section{M\'{o}dulo T\'{i}tulo}
\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{T\'{i}tulo}.\\

  \textbf{g\'{e}neros}: \TipoVariable{titulo}.\\

  \Title{Operaciones}
  \InterfazFuncion{nombre} {\In{t}{titulo}}{nombre}
  {$\sombrero{res} \igobs nombre(\sombrero{t})$}            %post
  [$O(1)$]                                                  %complejidad
  [Devuelve el nombre del t\'{i}tulo.]                        %descripcion
  [?]
  \\   \\                                                    
  \tab \InterfazFuncion{cantMax}{\In{t}{titulo}}{nat}
  {$\sombrero{res}$\ $\igobs$\ $\#$m\'{a}xAcciones(t)}
  [$O(1)$]
  [Devuelve la cantidad m\'{a}xima de acciones disponibles para wolfie.]
  \\ \\
  \tab \InterfazFuncion{cot} {\In{t}{titulo}}{nat}
  {$\sombrero{res}$\ $\igobs$\ cotizaci\'{o}n($\sombrero{t}$)}
  [$O(1)$]
  [Devuelve la cotizaci\'{o}n actual del t\'{i}tulo.]
  \\ \\
  \tab \InterfazFuncion{enAlza}{\In{t}{titulo}}{bool}
  {$\sombrero{res}$\ $\igobs$\ enAlza($\sombrero{t}$)}
  [$O(1)$]
  [Devuelve true si la cotizaci\'{o}n del t\'{i}tulo al recotizar es mayor a la anterior, o si nunca se aplic\'{o} recotizar sobre ese t\'{i}tulo, y false en caso contrario.]
  \\ \\
  \tab \InterfazFuncion{nuevoT}{\In{nt}{nombre},\ \In{cot}{dinero},\ \In{cantMax}{nat}}{titulo}
  {nombre($\sombrero{res}$)\ $\igobs$\ $\sombrero{nt}$\ $\wedge$\ $\#$m\'{a}xAcciones($\sombrero{res}$)\ $\igobs$\ $\sombrero{cantMax}$\ $\wedge$\ cotizaci\'{o}n($\sombrero{res}$)\ $\igobs$\ $\sombrero{cot}$\ $\wedge$\ enAlza($\sombrero{res}$)\ $\igobs$\ true}
  [$O(1)$]
  [Crea un nuevo t\'{i}tulo cuyos nombre, cotizaci\'{o}n y cantidad de acciones disponibles son aquellos pasados por par\'{a}metro]
  [nt es modificable si y solo si res es modificable]
  \\ \\
  \tab \InterfazFuncion{recotizar}{\In{cot}{dinero},\ \Inout{t}{titulo}}{}
  [$\sombrero{t}$\ $\igobs$\ $t_0$]
  {$\sombrero{t}$\ $\igobs$\ recotizar($\sombrero{cot}$,\ $t_0$)}
  [$O(1)$]
  [Cambia la cotizaci\'{o}n del titulo por la cot que se indique]
  [?]
  \\ \\
  \tab \InterfazFuncion{cotActual}{\In{nt}{nombre},\ \In{ts}{conj(titulo)}}{nat}
  [($\exists$\ t:titulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$)]
  {($\exists$\ t:titulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$\ $\wedge$\ cotizaci\'{o}n(t)\ $\igobs$\ $\sombrero{res}$ )}
  [$O(Cardinal(ts))$]
  [Devuelve la cotizaci\'{o}n del t\'{i}tulo cuyo nombre coincide con el pasado por par\'{a}metro]
  \\ \\
  \tab \InterfazFuncion{cambiarCotTs}{\In{nt}{nombre},\ \In{cot}{dinero},\ \Inout{ts}{conj(titulo)}}{}
  [($\exists$\ t:titulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$)\ $\wedge$\ $\sombrero{ts}$\ $\igobs$\ $ts_0$]
  {$\sombrero{ts}$\ $\igobs$\ cambiarCotizaci\'{o}n($\sombrero{nt}$,\ $\sombrero{cot}$,\ $ts_0$)}
  [$O(Cardinal(ts))$]
  [Cambia la cotizaci\'{o}n del t\'{i}tulo cuyo nombre coincide con el pasado por par\'{a}metro por la cotizaci\'{o}n (tambi\'{e}n pasada por par\'{a}metro)]
  [?]
  \\ \\
  \tab \InterfazFuncion{limTen}{\In{nt}{nombre},\ \In{ts}{conj(titulo)}}{nat}
  [($\exists$\ t:titulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$)]
  {($\exists$\ t:titulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$\ $\wedge$\ $\#$m\'{a}xAcciones(t)\ $\igobs$\ $\sombrero{res}$ )}
  [$O(Cardinal(ts))$]
  [Devuelve la cantidad m\'{a}xima de acciones disponibles para wolfie del t\'{i}tulo cuyo nombre coincide con el pasado por par\'{a}metro]
  \\ \\
  \tab \InterfazFuncion{titEnAlza}{\In{nt}{nombre},\ \In{ts}{conj(titulo)}}{bool}
  [($\exists$\ t:titulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$)]
  {($\exists$\ t:titulo)(t\ $\in$\ $\sombrero{ts}$\ $\wedge$\ nombre(t)\ $\igobs$\ $\sombrero{nt}$\ $\wedge$\ enAlza(t)\ $\igobs$\ $\sombrero{res}$ )}
  [$O(Cardinal(ts))$]
  [Informa si las acciones del t\'{i}tulo cuyo nombre coincide con el pasado por par\'{a}metro est\'{a}n en alza ]
\end{Interfaz}\\ \\ \\
\begin{Representacion}
 \Title{Representaci\'{o}n}
    \begin{Tupla}[t\'{i}tulo] 
      \tupItem{nombre}{string}
      \tupItem{cantMax}{nat}
      \tupItem{cot}{nat}
      \tupItem{enAlza}{bool}
    \end{Tupla} 
    
      \Rep[estr][t]{true}\mbox{}
      \AbsFc[estr]{titulo}[t]{nombre(t)=t.nombre,\\$\wedge \#$maxAcciones(t)=t.cantMax\\$\wedge$ cotizacion(t)=t.cot \\$\wedge$ enAlza(t)=t.enAlza}
      
\end{Representacion}
\begin{Algoritmos}
\\ \\
  \NombreFuncion{inombre}(\In{t}{t\'{i}tulo})$\rightarrow$ res:string
\\
\tab res\ $\leftarrow$\ t.nombre \hfill $O(1)$
\\ \\
  \NombreFuncion{icantMax}(\In{t}{t\'{i}tulo}) $\rightarrow$ res:nat
\end{Algoritmos}
\\ \\
\tab res\ $\leftarrow$\ t.cantMax \hfill $O(1)$
\\ \\
  \NombreFuncion{icot}(\In{t}{t\'{i}tulo})$\rightarrow$ res:nat
\\
\tab res\ $\leftarrow$\ t.cot \hfill $O(1)$
\\ \\
  \NombreFuncion{ienAlza}(\In{t}{t\'{i}tulo})$\rightarrow$ res:bool
\\
\tab res\ $\leftarrow$\ t.enAlza \hfill $O(1)$
\\ \\
  \NombreFuncion{inuevoT}(\In{nt}{nombre},\ \In{cantMax}{nat},\ \In{cot}{dinero})$\rightarrow$ res:estr
\\
\tab res.nombre\ $\leftarrow$\ nt \hfill $O(1)$
\\
\tab res.cantMax\ $\leftarrow$\ cantMax \hfill $O(1)$
\\
\tab res.cot\ $\leftarrow$\ cot \hfill $O(1)$
\\
\tab res.enAlza\ $\leftarrow$\ true \hfill $O(1)$
\\ \\
  \NombreFuncion{irecotizar}(\In{cot}{dinero},\ \Inout{t}{estr})
\\
\tab t.enAlza\ $\leftarrow$\ cot>t.cot \hfill $O(1)$
\\
\tab t.cot\ $\leftarrow$\ cot \hfill $O(1)$
\\ \\
  \NombreFuncion{icotActual}(\In{nt}{nombre},\ \In{ts}{conj(estr)})\ $\rightarrow$\ res:nat
\\
\tab it\ $\leftarrow$ CrearIt(ts) \hfill $O(1)$
\\
\tab while(HaySiguiente(it)) 
\\
\tab \tab \textbf{if}(nombre(Siguiente(ts))\ =\ nt) \hfill $O(1)$
\\
\tab \tab \tab res\ $\leftarrow$\ Siguiente(ts).cot \hfill $O(1)$
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(it) \hfill $O(1)$
\\
\tab \textbf{endwhile} \hfill $O(Cardinal(ts))$
\\ \\
  \NombreFuncion{iCambiarCotTs}(\In{nt}{nombre},\ \In{cot}{dinero},\ \Inout{ts}{conj(estr)})
\\
\tab it\ $\leftarrow$ CrearIt(ts) \hfill $O(1)$
\\
\tab while(HaySiguiente(it)) 
\\
\tab \tab \textbf{if}(nombre(Siguiente(ts))\ =\ nt) \hfill $O(1)$
\\
\tab \tab \tab Siguiente(ts).cot\ $\leftarrow$\ cot \hfill $O(1)$
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(it) \hfill $O(1)$
\\
\tab \textbf{endwhile} \hfill $O(Cardinal(ts))$
\\ \\
  \NombreFuncion{ilimTen}(\In{nt}{nombre},\ \In{ts}{conj(estr)})
\\
\tab it\ $\leftarrow$ CrearIt(ts) \hfill $O(1)$
\\
\tab while(HaySiguiente(it)) \hfill $O(1)$
\\
\tab \tab \textbf{if}(nombre(Siguiente(ts))\ =\ nt) \hfill $O(1)$
\\
\tab \tab \tab res\ $\leftarrow$\ Siguiente(ts).cantMax \hfill $O(1)$
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(it) \hfill $O(1)$
\\
\tab \textbf{endwhile} \hfill $O(Cardinal(ts))$
\\ \\
  \NombreFuncion{ititEnAlza}(\In{nt}{nombre},\ \In{ts}{conj(estr)})
\\
\tab it\ $\leftarrow$ CrearIt(ts) \hfill $O(1)$
\\
\tab while(HaySiguiente(it)) \hfill $O(1)$
\\
\tab \tab \textbf{if}(nombre(Siguiente(ts))\ =\ nt) \hfill $O(1)$
\\
\tab \tab \tab res\ $\leftarrow$\ Siguiente(ts).enAlza \hfill $O(1)$
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(it) \hfill $O(1)$
\\
\tab \textbf{endwhile} \hfill $O(Cardinal(ts))$
\\
s



\section{M\'{o}dulo Wolfie}


\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{Wolfie}.\\

  \textbf{g\'{e}neros}: \TipoVariable{wolfie}.\\

  \Title{Operaciones}

  \InterfazFuncion{Clientes}{\In {w}{wolfie}}{itBi(cliente)}
  {$\sombrero{res} \igobs clientes(\sombrero{w})$}
  [O(1)]
  [Devuelve un iterador de los clientes de wolfie.]
  [?]

  \InterfazFuncion{T\'{i}tulos}{\In {w}{wolfie}}{itBi(t\'{i}tulo)}
  {$\sombrero{res} \igobs T$\'{i}$tulos(\sombrero{w})$}
  [O(1)]
  [Devuelve un iterador de los t\'{i}tulos de wolfie.]
  [?]

  \InterfazFuncion{promesasDe} {\In {c}{cliente}, \In {w}{wolfie}} {itBi(promesa)}
  [$\sombrero{c} \in clientes(\sombrero{w})$]
  {$res \igobs promesasDe(c,w)$}
  [$O(T \cdot C \cdot |max_nt|)$ y O(1) para sucesivas llamadas con el mismo c, salvo que se use actualizarCotizacion antes]
  [Devuelve todas las promesas del cliente c]
  [?]
  
  \InterfazFuncion{accionesPorCliente}{\In {c}{cliente}, \In {nt}{nombre}, \In {w}{wolfie}}{nat}
  [$\sombrero{c} \in clientes(\sombrero{w}) \wedge (\exists t: $t\'{i}tulo)$(t \in\ $t\'{i}tulos$(\sombrero{w}) \wedge nombre(t) = \sombrero{nt})$]
  {$\sombrero{res} \igobs accionesPorCliente(\sombrero{c}, \sombrero{nt}, \sombrero{w})$}
  [$O(log(C)+|nt|)$]
  [Devuelve las acciones que tiene el cliente c del titulo cuyo nombre es nt]

  \InterfazFuncion{Inaugurar Wolfie}{\In {cs}{conj(cliente)}}{wolfie}
  [$\neg \emptyset  $($\sombrero{cs}$)]
  {$\sombrero{res} \igobs inaugurarWolfie(\sombrero{cs}$)}
  [$O(\# cs^{2})$]
  [Crea un wolfie cuyos clientes son los de cs, sin titulos ni promesas.]
  [?]

  \InterfazFuncion{agregarT\'{i}tulo}{\In {t}{t\'{i}tiulo}, \Inout {w}{wolfie}}{}
  [$\sombrero{w} \igobs w_0 \yluego (\forall\ t2: $t\'{i}tulo$)(t \in\ $t\'{i}tulos$(\sombrero{w}) \Rightarrow nombre(\sombrero{t}) \neq nombre(t2)) $]
  {$w \igobs agregarT$\'{i}$tulo(\sombrero{t},w_0)$}
  [$O(|nombre(t)| + C)$]
  [Agrega el t\'{i}tulo t a los t\'{i}tulos de wolfie]
  [?]

  \InterfazFuncion{actualizarCotizaci\'{o}n}{\In {nt}{nombre}, \In {cot}{nat}, \Inout {w}{wolfie}}{}
  [$\sombrero{w} \igobs w_0 \yluego \exists(t: t$\'{i}$tulo)(t \in t$\'{i}$tulos(\sombrero{w}) \wedge nombre(t) = \sombrero{nt}) $]
  {$\sombrero{w} \igobs actualizarCotizaci$\'{o}$n (\sombrero{nt}, \sombrero{cot}, w_0)$}
  [$O(|nt| + C \cdot log(C))$]
  [Cambia la cotizaci\'{o}n del t\'{i}tulo nt por cot. Actualiza EnAlza y ejecuta las promesas]
  [?]

  \InterfazFuncion{agregarPromesa}{\In {c}{cliente}, \In {p}{promesa}, \Inout {w}{wolfie}}{}
  [$\sombrero{w} \igobs w_0 \yluego (\exists t: t$\'{i}$tulo)(t \in t$\'{i}$tulos(\sombrero{w}) \wedge nombre(t) = t$\'{i}$tulo(\sombrero{p})) \wedge \sombrero{c} \in clientes(\sombrero{w}) \yluego (\forall p2: promesa)(p2 \in promesasDe(\sombrero{c}, \sombrero{w}) \Rightarrow (t$\'{i}$tulo(\sombrero{p}) \neq t$\'{i}$tulo(p2) \vee tipo(\sombrero{p}) \neq tipo(p2)) ) \wedge (tipo(\sombrero{p}) = vender \Rightarrow accionesPorCliente(\sombrero{c}, t$\'{i}$tulo(\sombrero{p}), \sombrero{w}) \geq cantidad(\sombrero{p}) ) )$]
  {$\sombrero{w} \igobs agregarPromesa (\sombrero{nt}, \sombrero{cot}, w_0)$}
  [$O(|titulo(p)| + log(C))$]
  [Agrega la promesa p al cliente c]
  [?]

  \InterfazFuncion{enAlza}{\In {nt}{nombre}, \In {w}{wolfie}}{bool}
  [$\exists(t: t$\'{i}$tulo)(t \in t$\'{i}$tulos(\sombrero{w}) \wedge nombre(t) = \sombrero{nt}) $]
  {$\sombrero{res} \igobs enAlza (\sombrero{nt}, \sombrero{w})$}
  [$O(|nt|)$]
  [Devuelve true si el t\'{i}tulo cuyo nombre es nt est\'{a} en alza, es decir, o bien su cotizaci\'{o}n es mayor a la que ten\'{i}a al ejecutar por \'{u}ltima vez actualizarCotizacion sobre ese t\'{i}tulo, o bien nunca se actualiz\'{o} su cotizaci\'{o}n]

\end{Interfaz}

\begin{Representacion}

  \begin{Estructura}{wolfie}[estr]
    \begin{Tupla}[estr]
      \tupItem{clientes}{conj(cliente)}\\
      \tupItem{titulos}{conj(t\'{i}tulo)}\\
      \tupItem{datosTitulo}{diccT(string,tupla<titulo:titulo, cantWolfie:acciones, diccCli:diccOrd(cliente,\ datosCliente)>)}\\
      \tupItem{accTxCliente}{diccOrd(cliente, acciones)}\\
      \tupItem{promUlt}{conj(tupla<cliente:cliente,\ promesas:conj(promesa)>)}
    \end{Tupla}

  \end{Estructura}
  
  \begin{Tupla}[datosCliente]
      \tupItem{acc}{acciones}\\
      \tupItem{pCompra}{conj(promesa)}\\
      \tupItem{pVenta}{conj(promesa)}
    \end{Tupla}
\\ \\ \\
\textbf{Descripcion del Rep:}
\\ \\
\textbf{1)} Los clientes de w.Clientes son los mismos que las claves de w.accTxCliente y que las claves de diccCli para todo titulo. Ademas son no vacios.
\\ \\
\textbf{2)} Los titulos de w.Titulos son los mismos que las claves de w.datosTitulo.
\\ \\
\textbf{3)} Para todo cliente de W, la suma de sus acciones de todos los titulos es igual a su significado en
w.accTxCliente
\\ \\
\textbf{4)} La suma de las acciones de todos los clientes sobre un titulo es igual a cantWolfie de ese titulo 
\\ \\
\textbf{5)} Wolfie no puede tener mas acciones de un titulo que la cantidad maxima de ese titulo.
\\ \\
\textbf{6)} En cada significado de datosCliente no puede existir una promesa de Venta con una cantidad mayor a las acciones del cliente sobre el titulo.
\\ \\
\textbf{7)} Para cada significado de datosCliente, pCompra y pVenta son conjuntos vacios o de longitud 1. En pCompra solo puede haber de compra y en pVenta, de venta. Asimismo, el titulo de las promesas deben corresponder con la clave. (Dividimos en 7.1 para venta y 7.2 para compra)
\\ \\
\textbf{8)} PromUlt es vacio o de longitud 1 y tiene las promesas de un cliente sobre todos los titulos.
\\ \\
\textbf{9)} Los nombres de datosTitulo corresponden con el nombre del titulo.
\\ \\ \\	
  \Rep[estr][w]{\textbf{1)}($\forall$ t:nombre) t $\in$ claves(w.datosTitulo) $\Rightarrow (\forall$ c:cliente) c $\in$ clientes $\Leftrightarrow$ def?(c,\ w.accTxCliente) $\Leftrightarrow$ def? (c,obtener(t,\ w.datosTitulo))) $\wedge \neg \emptyset$?(w.clientes)\\ \\
  \textbf{2)} $\wedge (\forall$ t:titulo) t $\in$ w.titulos $\Leftrightarrow$ t $\in$ claves(w.datosTitulo)\\ \\
  \textbf{3)} $\wedge (\forall$ c:cliente) c $\in$ w.clientes $\impluego$ obtener(c,\ w.accTxCliente) = $\sum_{t \in w.titulos}^{}$ (obtener(c, (obtener(nombre(t), w.diccTitulo)).datosCliente).acc) \\ \\
  \textbf{4)} $\wedge (\forall$ t:nombre) (def?(t, w.datosTitulo)) $\impluego$ obtener(t,w.datosTitulo).accWolfie = $\sum_{c \in clientes(c)}^{}$ TitXCli(c,t,w).acc \\ \\
  \textbf{5)} $\wedge (\forall$ t:titulo) (t $\in$ w.titulos) $\impluego$ (cantMax(t) $\leq$ (obtener(nombre(t),w.datosTitulo).cantWolfie))\\ \\
  \textbf{6)} $\wedge (\forall$ c:cliente, t:nombre) (c $\in$ w.clientes $\wedge$ def?(t,w.datosTitulo) $\yluego \neg \emptyset$?(TitXCli(c,t,w)).pVenta) $\impluego$ cantidad(dameUno(TitXCli(c,t,w).pVenta)) $\leq$ TitXCli(c,t,w).acc \\ \\
  \textbf{7.1)} $\wedge (\forall$ c:cliente, t:nombre) (c $\in$ w.clientes $\wedge$ def?(t,w.datosTitulo)) $\impluego$ ($\neg \emptyset$?(TitXCli(c,t,w)).pVenta $\impluego (\#$(TitXCli(c,t,w).pVenta)=1 $\wedge$ tipo(dameUno(TitXCli(c,t,w).pVenta))=vender) $\wedge$ (nombre(dameUno(TitXCli(c,t,w).pVenta))=t) \\
  \textbf{7.2)}$\wedge \neg \emptyset$?(TitXCli(c,t,w)).pCompra $\impluego (\#$(TitXCli(c,t,w).pCompra)=1 $\wedge$ tipo(dameUno(TitXCli(c,t,w).pCompra))=comprar)) $\wedge$ (nombre(dameUno(TitXCli(c,t,w).pCompra))=t)  \\ \\
  \textbf{8)}$\wedge$ ($\emptyset$?(w.promUlt) $\oluego$ ((w.promUlt)=1 $\wedge$ (w.promUlt).cliente $\in$ w.clientes) $\yluego (\forall$ p:promesa) p $\in$ (dameUno(w.promUlt).promesas) $\Leftrightarrow (\exists$ n:nombre) ($\neg \emptyset$? (TitXCli(dameUno(w.promUlt).cliente,n,w).pCompra) $\yluego$ dameUno(TitXCli(dameUno(w.promUlt).cliente,n,w).pCompra)=p $\vee \neg \emptyset$? (TitXCli(dameUno(w.promUlt).cliente,n,w).pVenta) $\yluego$ dameUno(TitXCli(dameUno(w.promUlt).cliente,n,w).pVenta)=p) \\ \\
  \textbf{9)} $\wedge (\forall$ t:nombre) def?(t,w.datosTitulo) $\impluego$ nombre(obtener(t,w.datosTitulo).titulo)=t \\ 
  
  }\mbox{} 
    
  \NombreFuncion{TitXCli} (c:cliente, t:nombre, w:wolfie) $\rightarrow$ datosCliente \\
  TitXCli(c,t,w) = obtener(c,obtener(t, w.datosTitulo).datosCliente) \\ \\
   \AbsFc[estr]{wolfie}[w]{clientes(w)=w.clientes\\$\wedge$ titulos(w)=w.titulos,\\$\wedge$ ($\forall$ c:cliente) c $\in$ clientes(w) $\impluego$ promesasDe(w,c)=(el conjunto de todas las promesas de compra y de venta de ese cliente sobre cada titulo)\\$\wedge$ ($\forall$ c:cliente, nt:nombre) (c $\in$ clientes(w) $\wedge (\exists$ t:titulo) (nombre(t)=nt $\wedge$ t $\in$ titulos(w))) $\impluego$ Accionesporcliente(c,nt,w)=obtener(c,(obtener(nt,e.datosTitulo)).acc)}


\end{Representacion}

\begin{Algoritmos}
\\
\NombreFuncion{iClientes}(\In{w}{estr}) $\rightarrow$ res:itConj(cliente)
\\
\tab res $\leftarrow$ crearIt(w.clientes) \hfill O(1)
\\ \\
\NombreFuncion{iTitulos}(\In{w}{estr}) $\rightarrow$ res:itConj(titulos)
\\
\tab res $\leftarrow$ crearIt(w.titulos) \hfill O(1)
\\ \\
\NombreFuncion{PromesasDe}(\In{c}{cliente}, \Inout{w}{estr}) $\rightarrow$ res:itConj(promesa)
\\
\tab prom $\leftarrow$ Vacio() \hfill O(1)
\\ 
\tab \textbf {if} esVacio?(w.promUlt) $\oluego$ siguiente(crearIt(w.promUlt)).cliente $\neq$ c \hfill O(1)
\\
\tab \tab t $\leftarrow$ crearIt(w.titulos) \hfill O(1)
\\
\tab \tab \textbf{while} hayMas(t) \hfill O(1)
\\
\tab \tab \tab datosCli $\leftarrow$ significado(c, significado(siguiente(t),\ w.datosTitulo).diccCli) \hfill O(|nt|+log(C))
\\
\tab \tab \tab \textbf{if} $\neg$ esVacio(datosCli.pCompra) \hfill O(1)
\\
\tab \tab \tab \tab agregarRapido(prom,\ siguiente(crearIt(datosCli.pCompra))) \hfill O(1)
\\
\tab \tab \tab \textbf{endif}
\\
\tab \tab \tab \textbf{if} $\neg$ esVacio(datosCli.pVenta) \hfill O(1)
\\
\tab \tab \tab \tab agregarRapido(prom,\ siguiente(crearIt(datosCli.pVenta))) \hfill O(1)
\\
\tab \tab \tab \textbf{endif} 
\\
\tab \tab \tab avanzar(t) \hfill O(1)
\\
\tab \tab \textbf{endwhile} \hfill O(T(log(C) + |max$\_$nt|))
\\
\tab \tab res $\leftarrow$ crearIt(prom) \hfill O(1)
\\
\tab \tab w.promUlt=Vacio() \hfill O(1)
\\
\tab \tab agregarRapido(w.promUlt,\ <c,prom>) \hfill O(1)
\\
\tab \textbf{else}
\\
\tab \tab res $\leftarrow$ crearIt(siguiente(crearIt(w.promUlt)).promesas) \hfill O(1)
\\
\tab \textbf{endif}
\\ \\
\NombreFuncion{iAccionesPorCliente}(\In{c}{cliente},\ \In {nt}{nombre},\ \In {w}{estr}) $\rightarrow$ (res:nat)
\\
\tab datoCli $\leftarrow$ significado(nt, w.datosTitulo).diccCli \hfill O(|nt|)
\\
\tab res $\leftarrow$ significado(c,\ datoCli).acc \hfill O(log(C))
\\
\textbf{complejidad total}: O(|nt|+log(C))
\\ \\
\NombreFuncion{iInaugurarWolfie}(\In{cl}{conj(cliente)}) $\rightarrow$ (res:estr)
\\
\tab cs $\leftarrow$ crearIt(cl) \hfill O(C $\cdot$ log(C))
\\
\tab \textbf{while} haySiguiente(cs) \hfill O(1)
\\
\tab \tab agregarRapido(res.clientes,\ siguiente(cs)) \hfill O(1)
\\
\tab \tab definir(res.accTxCliente, siguiente(cs),0) \hfill O(C)
\\
\tab \tab avanzar(cs) \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O($\#(cl)^{2}$)
\\
\tab res.titulos $\leftarrow$ Vacio() \hfill O(1)
\\
\tab res.promUlt $\leftarrow$ Vacio() \hfill O(1)
\\
\textbf{Complejidad total}: O($\#(cl)^{2}$)
\\ \\
\NombreFuncion{iAgregarTitulo}(\In{t}{t\'{i}tulo},\ \Inout{w}{estr})
\\
\tab t2 $\leftarrow$ crearTitulo(nombre(t),cot(t),cantMax(t)) \hfill O(1)
\\
\tab agregarRapido(w.titulos,\ t2) \hfill O(1)
\\
\tab definir(w.datosTitulo,\ nombre(t2),\ <t2,\ 0,\ CrearDiccAccC(w.accTxCliente, <0,\ Vacio(),\ Vacio()>)>) \hfill O(|nt|+C) 
\\
\textbf{Complejidad Total}: O(|nt|+C)
\\ \\
\NombreFuncion{crearDiccAccC} (\In{cs}{diccOrd(cliente,\ acciones)}, \In{t}{tupla<nat,\ conj(promesa),\ conj(promesa)>}) $\rightarrow$ res:diccOrd(cliente,tupla<nat,\ conj(promesa),\ conj(promesa)>)
\textbf{pre} $\equiv \{$ true $\}$
\\
\textbf{post} $\equiv \{ (\forall$ c:cliente) definido?(c, res) $\impluego$ obtener(c, res)=t $\}$
\\
\tab c $\leftarrow$ crearIt(cs)
\\
\tab \textbf {while} haySiguiente(cs) \hfill O(1)
\\
\tab \tab definirRapido(siguiente(cs),t) \hfill O(1)
\\
\tab \tab avanzar(cs)  \hfill O(1)
\\
\tab \textbf {endwhile}  \hfill O(C)
\\ \\
	
\NombreFuncion{iActualizarCotizaci\'{o}n}(\In{nt}{string},\ \In{cot}{nat},\ \Inout{w}{estr})

\tab datos $\leftarrow$ significado(nt,\ w.datosTitulo) \hfill O(|nt|)
\\ 
\tab (datos.titulo) $\leftarrow$ recotizar(datos.titulo) \hfill O(1)
\\
\tab itDiccCli $\leftarrow$ crearIt(datos.diccCli)
\\
\tab \textbf{while} hayMas?(itDiccCli) \hfill O(1)
\\
\tab \tab dcli $\leftarrow$ siguienteSignificado(itDiccCli) \hfill O(1) 
\\
\tab \tab c $\leftarrow$ siguienteClave(itDiccCli) \hfill O(1) 
\\
\tab \tab \textbf{if} $\#$(dcli.pVenta)>0 $\yluego$ (promesaEjecutable(siguiente(crearIt(dcli.pCompra))), cot, ((datos.titulo).cantMax)-(datos.accWolfie)) \hfill O(1)
\\
\tab \tab \tab significado(c,\ w.accTxCliente) $\leftarrow$ significado(c,\ w.accTxCliente-cantidad(siguiente(crearIt(dcli.pVenta))) \hfill O(log(C))
\\
\tab \tab \tab dcli.acc $\leftarrow$ dcli.acc-cantidad(siguiente(crearIt(dcli.pVenta))) \hfill O(1)
\\
\tab \tab \tab dcli.pVenta $\leftarrow$ Vacio() \hfill O(1)
\\
\tab \tab \tab w.PromUlt $\leftarrow$ Vacio() \hfill O(1)
\\
\tab \tab \textbf{endif}
\\
\tab \tab avanzar(itDiccCli) \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O(C $\cdot$ log(C))
\\
\tab arreglo(cliente, acciones) cliO $\leftarrow$ diccOrd2ArrOrd(w.accTxCliente) \hfill O(C $\cdot$ log(C))
\\
\tab nat i $\leftarrow$ 0 \hfill O(1)
\\
\tab \textbf{while} i<longitud(CliO) \hfill O(1)
\\
\tab \tab dcli $\leftarrow$ significado(siguienteClave(cliO),datos.diccCli) \hfill O(log(C)) 
\\
\tab \tab c $\leftarrow$ siguienteClave(datos.diccCli) \hfill O(1) 
\\
\tab \tab \textbf{if} $\#$(dcli.pCompra)>0 $\yluego$ (promesaEjecutable(siguiente(crearIt(dcli.pCompra))), cot, ((datos.titulo).cantMax)-(datos.accWolfie)) \hfill O(1)
\\
\tab \tab \tab significado(c,\ w.accTxCliente) $\leftarrow$ significado(c,\ w.accTxCliente+cantidad(siguiente(crearIt(dcli.pCompra))) \hfill O(log(C))
\\
\tab \tab \tab dcli.acc $\leftarrow$ dcli.acc+cantidad(siguiente(crearIt(dcli.Compra))) \hfill O(1)
\\
\tab \tab \tab dcli.pCompra $\leftarrow$ Vacio() \hfill O(1)
\\
\tab \tab \tab w.PromUlt $\leftarrow$ Vacio() \hfill O(1)
\\
\tab \tab \textbf{endif}
\\
\tab \tab i $\leftarrow$ i+1 \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O(C $\cdot$ log(C))
\\
\textbf{Complejidad Total}: O(|nt|+C $\cdot$ log(C))
\\ \\
\NombreFuncion{diccOrd2ArrOrd}(\In{d}{diccOrd(cliente,\ acciones)}) $\rightarrow$ res:arreglo(tupla<(cliente,\ acciones)>)
\\
\textbf{Pre} $\equiv$ \{ $\neg$ esVacio?(d) \}
\\
\textbf{Post} $\equiv$ \{ ($\forall$ i, j: nat) (i<longitud(res)) $\wedge$ (j<longitud(res)) $\impluego$ ($\Pi_2$(res[i])$\leq \Pi_2$(res[j]) \} 
\\
\tab i $\leftarrow$ 0 \hfill O(1)
\\
\tab di $\leftarrow$ crearIt(d) \hfill O(1)
\\
\tab arr $\leftarrow$ crearArreglo($\#$claves(d)) \hfill O(1)
\\
\tab \textbf {while} i < $\#$claves(d)) \hfill O(1)
\\
\tab \tab arr[i]=<siguienteClave(di), siguienteSignificado(di)> \hfill O(1)
\\
\tab \tab i $\leftarrow$ i+1 \hfill O(1)
\\
\tab \tab avanzar(di) \hfill O(1)
\\
\tab \textbf{endwhile} \hfill O(C)
\\
\tab res $\leftarrow$ Mergesort(arr) \hfill O(C $\cdot$ log(C))
\\ \\

\NombreFuncion {Merge}(\In{b}{arreglo(tupla<cliente, acciones>)}, \In{c}{arreglo\\(tupla<cliente, acciones>}) $\rightarrow$ res:arreglo(tupla<cliente, acciones>)
\\
\tab nat ib $\leftarrow$ 1;
\\
\tab nat ic $\leftarrow$ 1
\\
\tab res $\leftarrow$ CrearArreglo(tam(b) + tam(c))
\\
\tab nat i $\leftarrow$ 1
\\
\tab \textbf {while} i $\leq$ tam(a)
\\
\tab \tab \textbf {if} iB $\leq$ tam(b) $\wedge$ (ic > tam(c) $\vee \Pi_2$ b[ib] < $\Pi_2$c[ic])
\\
\tab \tab \tab res[i] $\leftarrow$ b[ib]
\\
\tab \tab \tab ib $\leftarrow$ ib + 1
\\
\tab \tab \textbf{else}
\\
\tab \tab \tab res[i] $\leftarrow$ c[ic]
\\
\tab \tab \tab ic $\leftarrow$ iC + 1
\\
\tab \tab \textbf{endif}
\\
\tab \tab i $\leftarrow$ i+1
\\
\tab \textbf {endwhile}
\\ \\

\NombreFuncion{MergeSort} (\Inout {a}{arreglo(tupla<cliente, acciones>)})
\\
\tab \textbf{if} tam(A)>1
\\
\tab \tab nat m $\leftarrow$ tam(a)/2
\\
\tab \tab arreglo(nat) b $\leftarrow$ Copiar(Subarreglo(a, 1, m))
\\
\tab \tab arreglo(nat) C $\leftarrow$ Copiar(Subarreglo(a, m + 1; tam(a)))
\\
\tab \tab MergeSort(b)
\\
\tab \tab MergeSort(c)
\\
\tab \tab a=Merge(b, c)
\\
\tab \textbf{endif}
\\ \\


\NombreFuncion{iAgregarPromesa}(\In{p}{promesa},\ \In{c}{cliente},\ \Inout{w}{estr})
\\ 
\tab datos $\leftarrow$ significado(c,\ (significado(titulo(p),\ w.datosTitulo))) \hfill O(log(C)+|nt|)
\\
\tab \textbf{if} (tipo(p)=vender) \hfill O(1)
\\
\tab \tab agregarRapido(datos.pVenta,\ p) \hfill O(1)
\\
\tab \textbf{else}
\\
\tab \tab agregarRapido(datos.pCompra,\ p) \hfill O(1)
\\
\tab \textbf{endif}
\\
\tab \textbf{if} $\neg$ esVacio?(w.promUlt) $\yluego$ siguiente(crearIt(w.promUlt))).cliente=c \hfill O(1)
\\
\tab \tab agregarRapido(siguiente(crearIt(w.promUlt))).promesas,\ p) \hfill O(1)
\\
\tab \textbf{endif}
\\
\textbf{Complejidad total}: O(log(C)+|nt|)
\\ \\
\NombreFuncion{iEnAlza}(\In{nt}{nombre},\In {w}{estr}) $\rightarrow$ (res:bool)
\\
\tab res $\leftarrow$ EnAlza(significado(nt, w.datosTitulo)) \hfill O(|nt|)
\\ \\

\end{Algoritmos}


\section{M\'{o}dulo Diccionario\ Ordenado(clave, significado)}
\begin {Interfaz}
  \textbf{parametros formales}\hangindent=2\parindent\\
  \parbox{1.7cm}{\textbf{generos}} $\kappa$, $\sigma$\\
  \parbox[t]{1.7cm}{\textbf{funcion}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{$\bullet$=$\bullet$}{\In{k1}{$\kappa$}, \In{k2}{$\kappa$}}{bool}
    {$res \igobs (c1=c2)$}
    [$\Theta(equal(c))$]
    [funcion de igualdad de $\kappa$'s]
  }
  \parbox[t]{1.7cm}{\textbf{funcion}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{c}{$\kappa$}}{$\kappa$}
    {$res \igobs c$}
    [$\Theta(copy(c))$]
    [funcion de copia de $\kappa$'s]
  }
  \parbox[t]{1.7cm}{\textbf{funcion}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{Copiar}{\In{a}{$\sigma$}}{$\sigma$}
    {$res \igobs a$}
    [$\Theta(copy(s))$]
    [funcion de copia de $\sigma$'s]
  }
  \parbox[t]{1.7cm}{\textbf{funcion}}\parbox[t]{\textwidth-2\parindent-1.7cm}{%
    \InterfazFuncion{$\bullet$<$\bullet$}{\In{c1}{$\kappa$} \In{c2}{$\kappa$}}{$\kappa$}
    {$res \igobs (c1<c2)$}
    [$\Theta(equal(c))$]
    [funcion de orden de $\kappa$'s]
  }
  \textbf{se explica con}: \tadNombre{Diccionario(clave, significado)}, modificado de la siguiente forma: \\

Observadores agregados: \\
\tab maxClaves: dicc(clave, significado) $\rightarrow$ nat \\
Generadores modificados: \\
\tab  vacio : nat $\rightarrow$ dicc(clave, significado) \\
\tab  definir : clave $\times$ significado $\times$ dicc(clave, significado) d $\rightarrow$ dicc(clave, significado) $\{ \#$(claves(d)) $\}$ \\
Nuevos axiomas: \\
\tab maxClaves(Vacio(n)) $\equiv$ n \\
\tab maxClaves(definir(c,s,d)) $\equiv$ maxClaves(d) \\

  
  \textbf{g\'{e}neros}: \TipoVariable{diccOrd}, \TipoVariable{itDiccOrd}

\tab El M\'{o}dulo Diccionario Ordenado provee un diccionario con una interfaz similar al diccionario lineal, es decir que muchas de sus operaciones b\'{a}sicas tienen los mismos argumentos de entrada y salida y cumplen los mismos Pre y Post. Se diferencian en las complejidades de las operaciones. Tiene tambi\'{e}n un m\'{a}ximo de claves que puede tener, que se especifica al crear el diccionario. Su iterador es unidireccional.\\
\\
  \tab \InterfazFuncion{Vacio}{\In{n}{nat}}{diccOrd($\kappa$, $\sigma$)}
  {res $\igobs$ vacio}
  [O(1)]
  [Crea un diccionario vacio cuyo maximo de claves es n]
\\ \\
  \tab \InterfazFuncion{definir}{\In{c}{$\kappa$},\ \In{s}{$\sigma$},\ \Inout{d}{diccOrd($\kappa$, $\sigma$)}}{itDiccOrd($\kappa$,\ $\sigma$)}
  [d $\igobs$ $d_0$ $\wedge \neg$ definido?(d, c) $\wedge$ $\#$claves(d) $\neq$ maxClaves(d)]
  {d $\igobs$ definir($d_0$; c; s) $\wedge$ haySiguiente(res) $\yluego$ Siguiente(res) = <c; s> $\wedge$ esPermutacion(SecuSuby(res),d)}
  [O($\#$claves(d) $\cdot$ (copy($\kappa$)+copy($\sigma$)))]
  [Define la clave c con el significado s en el diccionario]
  [Los elementos c y s se definen por copia. El iterador se invalida si y solo si se elimina el elemento siguiente
del iterador sin utilizar la funcion EliminarSiguiente. Ademas, siguientes(res) podria cambiar completamente ante cualquier operacion que modifique el d sin utilizar las funciones del iterador]
\\ \\
  \tab \InterfazFuncion{definirRapido}{\In{c}{$\kappa$},\ \In{s}{$\sigma$},\ \Inout{d}{diccOrd($\kappa$, $\sigma$)}}{itDiccOrd($\kappa$,\ $\sigma$)}
  [d $\igobs$ $d_0$ $\wedge \neg$ definido?(d, k) $\wedge (\forall$ c2 $\in$ claves(d)) c<c2  $\wedge$ $\#$claves(d) $\neq$ maxClaves(d)]
  {d $\igobs$ definir($d_0$; c; s) $\wedge$ haySiguiente(res) $\yluego$ Siguiente(res) = <c; s> $\wedge$ esPermutacion(SecuSuby(res),d)}
  [O(copy($\kappa$)+copy($\sigma$))]
  [Define la clave c con el significado s en el diccionario, requiere que c sea mayor a todo el resto de las claves del diccionario]
  [Los elementos c y s se definen por copia. El iterador se invalida si y solo si se elimina el elemento siguiente
del iterador sin utilizar la funcion EliminarSiguiente. Ademas, siguientes(res) podria cambiar completamente ante cualquier operacion que modifique el d sin utilizar las funciones del iterador]
\\ 
  \tab \InterfazFuncion{maxClaves}{\In{d}{diccOrd($\kappa$, $\sigma$)}}{nat}
  {d $\igobs$ maxClaves(d)}
  [O(1)]
  [Devuelve el maximo de claves del diccionario]
  \\
\tab \textbf{Las complejidades de las otras operaciones b\'{a}sicas son listadas a continuaci\'{o}n:} \\
\\
  \NombreFuncion{Definido?}(c,\ s,\ d): \tab O(log($\#$claves(d)) $\cdot$ equal($\kappa$)) 
\\
  \NombreFuncion{Significado}(c,\ d): \tab O(log($\#$claves(d)) $\cdot$ equal($\kappa$))
\\
  \NombreFuncion{Borrar}(c,\ d): \tab O($\#$claves(d) $\cdot$ (equal($\kappa$)+copy($\kappa$)+copy($\sigma$)))
\\
  \NombreFuncion{$\#$Claves}(d): \tab O(1)
\\
  \NombreFuncion{Copiar}(d): \tab O($\#$claves(d) $\cdot$ (copy($\kappa$)+copy($\sigma$)))
\\
  \NombreFuncion{d1=d2}: \tab O($\#$claves(d) $\cdot$ (copy($\kappa$)+copy($\sigma$)))
\\
\tab \textbf{Las operaciones del iterador definidas son las siguientes, con su complejidad:} \\
\\
  \NombreFuncion{crearIt(d)}: \tab O(1)
\\
  \NombreFuncion{haySiguiente(d)}: \tab O(1)
\\
  \NombreFuncion{siguiente(d)}: \tab O(1)
\\
  \NombreFuncion{siguienteClave(d)}: \tab O(1)
\\
  \NombreFuncion{siguienteSignificado(d)}: \tab O(1)
\\
  \NombreFuncion{avanzar(d)}: \tab O(1)


\end {Interfaz}

\begin{Representacion}
  
  \Title{Representaci\'{o}n del diccionario}

  \begin{Estructura}{diccOrd($\kappa$, $\sigma$)}[diccord]
    donde \TipoVariable{diccOrd} es tupla<elementos:array(tupla<$\kappa$,\ $\sigma$>), longitud:nat, lReal:nat>
  \end{Estructura}
  

  \Rep[$\sombrero{estr}$][d]{ ($\forall$ i,j:nat) (i<d.lReal $\wedge$ j<d.lReal) $\impluego$ ($\Pi_1$ d.elementos[i] $\neq \Pi_1$ d.elementos[j] $\wedge$ i<j $\Leftrightarrow \Pi_1$ d.elementos[i]< $\Pi_1$ d.elementos[j]) \\ $\wedge$ d.lReal $\leq$ d.longitud \\ $\wedge (\forall$i: nat)(0 $\leq$ i < d.longitud $\impluego$ def?(v.elementos, i)}\mbox{}
 
  \AbsFc[estr]{dicc($\kappa$,\ $\sigma$)}[d]{($\forall$ c:$\kappa$) def?(c,\ d)=($\exists$ s:$\sigma$, i:nat) d.elementos[i]=<c, s>) $\yluego (\forall$ c:$\kappa$) obtener(c, d)=$\Pi_2$ (d.elementos[buscarIndice(d,\ c,\ 0)])}

\NombreFuncion(buscarIndice) (estr, $\kappa$, nat) $\rightarrow$ nat
buscarIndice(e,\ c,\ i)= \textbf{if} $\Pi_1$ e[i]=c \textbf{then} i \textbf{else} buscarIndice(e,\ c,\ i+1) \textbf{fi}

  \Title{Representaci\'{o}n del iterador}

  \begin{Estructura}{itDiccOrd($\kappa$, $\sigma$)}[itDiccOrd]
	donde \TipoVariable{itDiccOrd} es tupla<elementos: array(<tupla($\kappa$),\ ($\sigma$)>$\ast$, i:nat, long:nat>
  \end{Estructura}

	\Rep[$\sombrero{estr}$][d]{i < long}\mbox{}
 
  	\AbsFc[estr]{}

\end{Representacion}

\begin{Algoritmos}

  \NombreFuncion{iVacio} (n:nat) $\rightarrow$ res:estr
\\
	\tab res.elementos $\leftarrow$ a[n] \hfill O(1)
\\
	\tab res.lReal $\leftarrow$ 0  \hfill O(1)
\\
	\tab res.longitud $\leftarrow$ n \hfill O(1)
\\ \\
  \NombreFuncion{iDefinir} (\Inout{d}{diccOrd($\kappa$, $\sigma$)}, \In{c}{$\kappa$}, \In{s}{$\sigma$}) $\rightarrow$ res:itDiccOrd($\kappa$, $\sigma$)
\\
	\tab i $\leftarrow$ 0 \hfill O(1)
\\
	\tab \textbf{while} i<d.lReal \hfill O(1)
\\
	\tab \tab \textbf{if} $\Pi_1$(d.elementos[i]) > c \hfill O(1)
\\
	\tab \tab \tab <a, b> $\leftarrow$ copy(d.elementos[i]) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab \tab \tab d.elementos[i] $\leftarrow$ copy(<c,s>) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab \tab \tab <c, s> $\leftarrow$ copy(<a, b>) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab \tab \textbf{endif}	
\\
	\tab \tab i $\leftarrow$ i+1 \hfill O(1)
\\
	\tab \textbf{endwhile} \hfill O(d.lreal $\cdot$ (copy($\kappa$)+copy($\sigma$)))
\\
	\tab d.elementos[i] $\leftarrow$ copy(<c, s>) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab d.lReal $\leftarrow$ d.lReal+1 \hfill O(1)
\\
	\tab res $\leftarrow$ crearIt(d)
\\ \\
  \NombreFuncion{iDefinirRapido} (\Inout{d}{diccOrd($\kappa$, $\sigma$)}, \In{c}{$\kappa$}, \In{s}{$\sigma$})  $\rightarrow$ res:itDiccOrd($\kappa$, $\sigma$)
\\
	\tab d.lReal $\leftarrow$ d.lReal+1 \hfill O(1)
\\
	\tab d.elementos[lReal+1] $\leftarrow$ copy(<c, s>) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab res $\leftarrow$ crearIt(d)
\\ \\
  \NombreFuncion{iDefinido?} (\In {d}{diccOrd} \In{c}{$\kappa$}) $\rightarrow$ res:bool
\\
	\tab i $\leftarrow$ (d.lReal)/2 \hfill O(1)
\\
	\tab max $\leftarrow$ d.lReal \hfill O(1)
\\
	\tab min $\leftarrow$ 0 \hfill O(1)
\\
	\tab res $\leftarrow$ false \hfill O(1)
\\
	\tab \textbf {while} max $\neq$ min $\wedge$ max $\neq$ min+1 $\wedge$ res=false \hfill O(1)
\\
	\tab \tab \textbf{if} $\Pi_1$ d.elementos[i]=c \hfill O(equal($\kappa$))
\\
	\tab \tab \tab res $\leftarrow$ true \hfill O(1)
\\
	\tab \tab \textbf{else if} $\Pi_1$ d.elementos[i]<c \hfill O(equal($\kappa$))
\\
	\tab \tab \tab min $\leftarrow$ i \hfill O(1)
\\
	\tab \tab \tab i $\leftarrow$ (i+max)/2 \hfill O(1)
\\
	\tab \tab \textbf{else} \hfill O(1)
\\
	\tab \tab \tab max $\leftarrow$ i \hfill O(1)
\\
	\tab \tab \tab i $\leftarrow$ (i+min)/2 \hfill O(1)
\\
	\tab \tab \textbf{endif}
\\
	\tab \textbf{endwhile} \hfill O(log($\#$claves(d)) $\cdot$ equal($\kappa$))
\\ \\
  \NombreFuncion{iSignificado} (\In {d}{diccOrd} \In{c}{$\kappa$}) $\rightarrow$ res:$\sigma$
\\
	\tab i $\leftarrow$ (d.lReal)/2 \hfill O(1)
\\
	\tab max $\leftarrow$ d.lReal \hfill O(1)
\\
	\tab min $\leftarrow$ 0 \hfill O(1)
\\
	\tab encontrado $\leftarrow$ false \hfill O(1)
\\
	\tab \textbf{while} $\neg$ encontrado \hfill O(1)
\\
	\tab \tab \textbf{if} $\Pi_1$ d.elementos[i]=c \hfill O(equal($\kappa$))
\\
	\tab \tab \tab res $\leftarrow$ $\Pi_1$ d.elementos[i] \hfill O(equal($\kappa$))
\\
	\tab \tab \tab encontrado $\leftarrow$ true \hfill O(1)
\\
	\tab \tab \textbf {else if} $\Pi_1$ d.elementos[i]<c \hfill O(equal($\kappa$))
\\
	\tab \tab \tab min $\leftarrow$ i \hfill O(1)
\\
	\tab \tab \tab i $\leftarrow$ (i+max)/2 \hfill O(1)
\\
	\tab \tab \textbf {else} \hfill O(1)
\\
	\tab \tab \tab max $\leftarrow$ i \hfill O(1)
\\
	\tab \tab \tab i $\leftarrow$ (i+min)/2 \hfill O(1)
\\
	\tab \tab \textbf{endif}
\\
	\tab \textbf{endwhile} \hfill O(log($\#$claves(d)) $\cdot$ equal($\kappa$))
\\ \\
  \NombreFuncion{iBorrar(\Inout{d}{diccOrd}, \In{c}{$\kappa$})}
\\
	\tab i $\leftarrow$ 0 \hfill O(1)
\\
	\tab encontrado $\leftarrow$ false  \hfill O(1)
\\
	\tab \textbf{while} i<(d.lReal-1) \hfill O(1)
\\
	\tab \tab \textbf{if} $\Pi_1$(d.elementos[i]) = c $\wedge$ encontrado=true \hfill O(equal($\kappa$))
\\
	\tab \tab \tab d.elementos[i] $\leftarrow$ copy(d.elementos[i+1]) \hfill O(copy($\kappa$)+copy($\sigma$))
\\
	\tab \tab \tab encontrado $\leftarrow$ true \hfill O(1)
\\
	\tab \tab \textbf{endif}
\\
	\tab \tab i $\leftarrow$ i+1 \hfill O(1)
\\
	\tab \textbf{endwhile} \hfill O(d.lReal $\cdot$ (equal($\kappa$)+copy($\kappa$)+copy($\kappa$)))
\\
	\tab d.lReal $\leftarrow$ d.lReal-1 \hfill O(1)
\\ \\
  \NombreFuncion{i$\#$Claves} (\In{d}{diccOrd}) $\rightarrow$ res:nat
\\
	\tab res $\leftarrow$ d.lReal \hfill O(1)
\\ \\
  \NombreFuncion{$\bullet$=$\bullet$} (\In{d1}{diccOrd($\kappa$, $\sigma$)}, \In{d2}{diccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:bool
\\
	\tab i $\leftarrow$ 0 \hfill O(1)
\\
	\tab res $\leftarrow$ true  \hfill O(1)
\\
	\tab \textbf{if} (d1.lreal $\neq$ d2.lReal) \hfill O(1)
\\
	\tab \tab res $\leftarrow$ false \hfill O(1)
\\
	\tab \textbf{else}
\\
	\tab \tab \textbf{while} i<d1.lReal \hfill O(1)
\\
	\tab \tab \tab \textbf{if} d1[i] = d2[i] \hfill O(equal($\kappa$)+equal($\sigma$))
\\
	\tab \tab \tab \tab res $\leftarrow$ false \hfill O(1)
\\
	\tab \tab \tab \textbf{endif}	
\\
	\tab \tab \tab i $\leftarrow$ i+1 \hfill O(1)
\\
	\tab \tab \textbf{endwhile} \hfill O(d1.lReal $\cdot$ (equal($\kappa$)+equal($\sigma$)))
\\
	\tab \textbf{endif}
\\ \\
  \NombreFuncion{iCrearIt} (\In{d}{DiccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:itDiccOrd($\kappa$, $\sigma$)
\\
	\tab res.i $\leftarrow$ 0 \hfill O(1)
\\
	\tab res.long $\leftarrow$ d.lReal \hfill O(1)
\\
	\tab res.elementos $\leftarrow \ast$(d.elementos) \hfill O(1)
\\ \\
  \NombreFuncion{iHaySiguiente} (\In{d}{itDiccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:bool
\\
	\tab res $\leftarrow$ d.i<d.long \hfill O(1)
\\ \\
  \NombreFuncion{isiguienteClave} (\In{d}{itDiccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:$\kappa$
\\
	\tab res $\leftarrow \Pi_1(\ast$d.elementos) \hfill O(1)
\\ \\
  \NombreFuncion{isiguienteSignificado} (\In{d}{itDiccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:$\sigma$
\\
	\tab res $\leftarrow \Pi_2(\ast$d.elementos)  \hfill O(1)
\\ \\
  \NombreFuncion{iSiguiente} (\In{d}{itDiccOrd($\kappa$, $\sigma$)}) $\rightarrow$ res:tupla<$\kappa$, $\sigma$>
\\
	\tab res $\leftarrow \ast$ d.elementos  \hfill O(1)
\\ \\
  \NombreFuncion{iAvanzar} (\Inout{d}{itDiccOrd($\kappa$, $\sigma$)})
\\
	\tab d.i $\leftarrow$ (d.i)+1  \hfill O(1)
\\
	\tab d.elementos $\leftarrow$ (d.elementos)+1  \hfill O(1)
\\ \\

\end{Algoritmos}

\section{M\'{o}dulo Diccionario Texto($\kappa$,\ $\sigma$)}

\begin{Interfaz}

  \textbf{se explica con}: \tadNombre{Diccionario}.
  
  \textbf{g\'{e}neros}: \TipoVariable{diccT}

  \NombreFuncion{Vacio()}: \tab O(1)
\\
  \NombreFuncion{Definir(d,c,s)}: \tab O(|c|)
\\
  \NombreFuncion{Definido?(d,c)}: \tab O(|c|)
\\
  \NombreFuncion{Significado(d,c)}: \tab O(|c|)
\\
  \NombreFuncion{Borrar(d,c)}: \tab O()
\\
  \NombreFuncion{$\#$Claves(d)}: \tab O(1)
\\
  \NombreFuncion{Copiar(d)}: \tab O($\#$Claves(d))
\\
  \NombreFuncion{$\bullet$=$\bullet$}: \tab O($\#$Claves(d))
\\

\end {Interfaz}

\begin {Representacion}

\begin{Representacion}
    \begin{Estructura}{diccT}[dicctrie]
    \begin{Tupla}[dicctrie] 
    \end{Tupla} 
    \end{Estructura}
      \Rep[dicctrie][d]{}\mbox{}
      \AbsFc[dicctrie]{diccT}[d]{}
      
\end{Representacion}


\end {Representacion}

\begin {Algoritmos}

  \NombreFuncion{Vacio}() $\rightarrow$ res:diccT($\kappa$, $\sigma$)
\\
  \NombreFuncion{Definir}(\Inout{d}{diccT($\kappa$, $\sigma$)},\In{c}{$\kappa$},\In{s}{$\sigma$})
\\
  \NombreFuncion{DefinirRapido}(\Inout{d}{diccT($\kappa$, $\sigma$)},\In{c}{$\kappa$},\In{s}{$\sigma$})
\\
  \NombreFuncion{Definido?}(\In{d}{diccT($\kappa$, $\sigma$)},\In{c}{$\kappa$},\In{s}{$\sigma$}) $\rightarrow$ res:bool
\\
  \NombreFuncion{Significado}(\In{d}{diccT($\kappa$, $\sigma$)},\In{c}{$\kappa$},\In{s}{$\sigma$}) $\rightarrow$ res:$\sigma$
\\
  \NombreFuncion{Borrar}(\Inout{d}{diccT($\kappa$, $\sigma$)},\In{c}{$\kappa$})
\\
  \NombreFuncion{$\#$Claves}(\In{d}{diccT($\kappa$, $\sigma$)},\In{c}{$\kappa$},\In{s}{$\sigma$}) $\rightarrow$ res:nat
\\
  \NombreFuncion{Copiar}(\In{d}{diccT($\kappa$, $\sigma$)}) \rightarrow res:diccT($\kappa$, $\sigma$)
\\
  \NombreFuncion{$\bullet$=$\bullet$}(\In{d1}{diccT($\kappa$, $\sigma$)}, \In{d2}{diccT($\kappa$, $\sigma$)}) $\rightarrow$ res:bool
\\

\end {Algoritmos}
\end{document}


