#include "Wolfie.h"


Wolfie::Wolfie(){
    _clientes=Conj<Cliente>();
    _accTxCliente=DiccAcot<Cliente,Acciones>();
    _datosTitulo=DiccT<tupla1>();
    _titulos=Conj<string>();
    _promUlt=Conj<tupla2>();
}

Wolfie::Wolfie(const Conj<Cliente> cl){
    _accTxCliente=DiccAcot<Cliente,Acciones>(cl.Cardinal());
    Conj<Cliente>::const_Iterador cs = cl.CrearIt();
    while (cs.HaySiguiente()) {
        _clientes.AgregarRapido(cs.Siguiente());
        _accTxCliente.Definir(cs.Siguiente(),0);
        cs.Avanzar();
    }   _datosTitulo=DiccT<tupla1>();
    _titulos=Conj<string>();
    _promUlt=Conj<tupla2>();
}

Conj<Cliente>::const_Iterador Wolfie::Clientes() const {
    return (_clientes.CrearIt());
}

Wolfie::itTitulo Wolfie::Titulos() {
	Wolfie w2 = *this;
	return Wolfie::itTitulo::itTitulo();
    //return CrearItT(&w2);
}  /// Lo comento hasta que reconozca tupla1, si no no buildea

Conj<Promesa>::Iterador Wolfie::promesasDe(Cliente c){
    Conj<Promesa> prom;
    Conj<Promesa>::Iterador res;
    if (_promUlt.EsVacio() || (_promUlt.CrearIt().Siguiente()._cliente == c )) {
        Conj<Nombre>::Iterador t = _titulos.CrearIt();
        while (t.HaySiguiente()) {
            datosCliente datosCli = _datosTitulo.Significado(t.Siguiente())._diccCli.Significado(c);
            if (!datosCli._pCompra.EsVacio()) {
                prom.AgregarRapido((datosCli._pCompra.CrearIt()).Siguiente()) ;
            }
            if (!datosCli._pVenta.EsVacio()) {
                prom.AgregarRapido((datosCli._pVenta.CrearIt()).Siguiente()) ;
            }
            t.Avanzar();
        }
        res = prom.CrearIt();
        _promUlt = Conj<tupla2>();
        tupla2 a;
        a._cliente=c;
        a._promesas=prom;
        _promUlt.AgregarRapido(a);
    } else {
        Conj<Promesa> a =_promUlt.CrearIt().Siguiente()._promesas;
        res=a.CrearIt();
    } return res;
}

Nat Wolfie::accionesPorCliente(Cliente c, Nombre nt) {
    return _datosTitulo.Significado(nt)._diccCli.Significado(c)._acc;
}
Wolfie Wolfie::inaugurarWolfie (Conj<Cliente> cl) {
    return Wolfie(cl);
}
void Wolfie::agregarTitulo(Titulo t) {
    Titulo t2 = t.nuevoT(t.nombre(),t.cot(),t.cantmax());
    _titulos.AgregarRapido(t.nombre());
    datosCliente a;
    a._acc=0;
    a._pCompra=Conj<Promesa>();
    a._pVenta=Conj<Promesa>();
    tupla1* b = new tupla1();
    b->_titulo=t2;
    b->_cantWolfie=0;
    b->_diccCli=DiccAcot<Cliente,datosCliente>(_clientes.Cardinal());
    DiccAcot<Cliente,Acciones>::Iterador cs=_accTxCliente.CrearIt();
    while (cs.HaySiguiente()) {
        (b->_diccCli).DefinirRapido(cs.Siguiente().clave, a);
        cs.Avanzar();
    }
    _datosTitulo.Definir(t2.nombre(), *b);
}

struct tuplaCA{
    Cliente cliente;
    Acciones acciones;
};
///a chequear mergesort !
void Merge(Arreglo<tuplaCA> *a, Arreglo<tuplaCA> *b, Nat low, Nat pivot, Nat high) {
    Nat h,i,j,k;
    h=low;
    i=low;
    j=pivot+1;
    while ((h<=pivot)&&(j<=high)) {
        if (((*a)[h]).cliente<=((*a)[j]).cliente) {
            b[i]=a[h];
            h++;
        } else {
            b[i]=a[j];
            j++;
        } i++;
    } if (h>pivot) {
        for (k=j; k<=high; k++) {
            b[i]=a[k];
            i++;
        }
    } else {
        for (k=h; k<=pivot; k++) {
            b[i]=a[k];
            i++;
        }
    } for(k=low; k<=high; k++) {
        a[k]=b[k];
    }
}

void MergesortAux(Arreglo<tuplaCA>* a,Arreglo<tuplaCA>* b, Nat low, Nat high) {
    Nat pivot;
    if(low<high) {
        pivot=(low+high)/2;
        MergesortAux(a,b,low,pivot);
        MergesortAux(a,b,pivot+1,high);
        Merge(a,b,low,pivot,high);
    }
}

void mergesort(Arreglo<tuplaCA> a){
    Arreglo<tuplaCA> b;
    MergesortAux(&a,&b,0,a.Tamanho());
}

Arreglo<tuplaCA> DiccAcot2ArrOrd (DiccAcot<Cliente,Acciones> d) {
    DiccAcot<Cliente,Acciones>::Iterador di =d.CrearIt();
    Arreglo<tuplaCA> arr=Arreglo<tuplaCA>(d.CantClaves());
    for (Nat i=0;i<d.CantClaves();i++) {
        arr[i].cliente = di.SiguienteClave();
        arr[i].acciones = di.SiguienteSignificado();
        di.Avanzar();
    } mergesort(arr);
    return arr;
}

void Wolfie::actualizarCotizacion(Nombre nt, Nat cot){
    /// Ahora creo que no hay nada que se pase por copia que no deba.
    tupla1 &datos=_datosTitulo.Significado(nt);
    datos._titulo.recotizar(cot);
    DiccAcot<Cliente,datosCliente>::Iterador itDiccCli=datos._diccCli.CrearIt();
    while (itDiccCli.HaySiguiente()) {
        datosCliente &dcli=itDiccCli.SiguienteSignificado();
        Cliente c=itDiccCli.SiguienteClave();
        if (dcli._pVenta.Cardinal()>0) {
          Promesa pv=dcli._pVenta.CrearIt().Siguiente();
          if (pv.promesaEjecutable(cot,datos._titulo.cantmax()-datos._cantWolfie)) {
            _accTxCliente.Significado(c)=_accTxCliente.Significado(c)-pv.cantidad();
            dcli._acc=dcli._acc-pv.cantidad();
            dcli._pVenta=Conj<Promesa>();
            _promUlt=Conj<tupla2>();
          }
        } itDiccCli.Avanzar();
    } Arreglo<tuplaCA> cliO = DiccAcot2ArrOrd(_accTxCliente);
    for (Nat i=0;i<cliO.Tamanho();i++) {
        Cliente c=cliO[i].cliente;
        datosCliente &dcli = datos._diccCli.Significado(c);
        if (dcli._pCompra.Cardinal()>0) {
          Promesa pc=dcli._pCompra.CrearIt().Siguiente();
          if (pc.promesaEjecutable(cot,datos._titulo.cantmax()-datos._cantWolfie)) {
            _accTxCliente.Significado(c)=_accTxCliente.Significado(c)+pc.cantidad();
            dcli._acc=dcli._acc+pc.cantidad();
            dcli._pCompra=Conj<Promesa>();
            _promUlt=Conj<tupla2>();
          }
        }
    }
}

Nat Wolfie::cantClientes() const {
    return _clientes.Cardinal();
}

Nat Wolfie::cantTitulos() const {
    return _titulos.Cardinal();
}

void Wolfie::agregarPromesa(Cliente c, Promesa p){
    datosCliente &datos = (_datosTitulo.Significado(p.titulo())._diccCli.Significado(c));
    if (p.tipo()==vender) {
        datos._pVenta.AgregarRapido(p);
    } else {
        datos._pCompra.AgregarRapido(p);
    } if (!(_promUlt.EsVacio()) && (_promUlt.CrearIt().Siguiente()._cliente==c)) {
        _promUlt=Conj<tupla2>();
    }
}

bool Wolfie::enAlza(Nombre nt){
    return _datosTitulo.Significado(nt)._titulo.enalza();
}

Wolfie::itTitulo Wolfie::CrearItT(Wolfie* w)
{
	return Wolfie::itTitulo::itTitulo();
}

//esto es un construcotr que recibe wolfies
Wolfie::itTitulo::itTitulo(Wolfie* w):
	it_dicc (&w->_datosTitulo.CrearIt())
   //it_dicc = itTitulo(d->CrearIt());
{}

//esto es un cosntructor vacio
Wolfie::itTitulo::itTitulo(){

}

//esto es un constructor por copia
Wolfie::itTitulo::itTitulo(Wolfie::itTitulo& otro){
    it_dicc = otro.it_dicc;
}

//esto es lo que falta segun el compilador
/*Wolfie::itTitulo::itTitulo(Wolfie::itTitulo otro){
    it_dicc = otro.it_dicc;
}*/


bool Wolfie::itTitulo::HaySiguiente(){
    return it_dicc->HaySiguiente();
}

Titulo& Wolfie::itTitulo::Siguiente() {
    return it_dicc->SiguienteSignificado()._titulo;
}

void Wolfie::itTitulo::Avanzar(){
    it_dicc->Avanzar();
}

itTitulo& operator = (const Wolfie::itTitulo& otro){
	it_dicc = otro.it_dicc;
    return *this;
}
