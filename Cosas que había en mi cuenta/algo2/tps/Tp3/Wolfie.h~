#include "DiccT.h"
#include "DiccOrd2.h"
#include "Titulo.h"

using namespace std;
using namespace aed2;

typedef Nat Cliente;
typedef Nat Acciones;

struct Wolfie {
private:
        struct datosCliente{
            Acciones _acc;
            Conj<Promesa> _pCompra;
            Conj<Promesa> _pVenta;
        };

        struct tupla1{
            Titulo _titulo;
            Acciones _cantWolfie;
            DiccAcot<Cliente, datosCliente> _diccCli;
        };
        struct tupla2{
            Cliente _cliente;
            Conj<Promesa> _promesas;
        };

        Conj<Cliente> _clientes;
        Conj<string> _titulos;
        DiccT<tupla1> _datosTitulo;
        DiccAcot<Cliente, Acciones> _accTxCliente;
        Conj<tupla2> _promUlt;

        DiccAcot<Cliente,datosCliente> crearDiccAccC (DiccAcot<Cliente, Acciones> cs, datosCliente t);
        Wolfie(const Conj<Cliente>);


	class itTitulo
	    {
	      public:

		itTitulo();

		itTitulo(Wolfie* w);

		itTitulo(Wolfie::itTitulo& otro);

		itTitulo(Wolfie::itTitulo otro);

		itTitulo& operator = (const Wolfie::itTitulo& otro);

		bool HaySiguiente() const;
		Titulo& Siguiente() const;
		void Avanzar();


		DiccT<tupla1>::Iterador *it_dicc;

//		itTitulo(DiccT<tupla1>* d);


	      private:


		//friend Wolfie::itTitulo Wolfie::CrearIt();

		//friend class Wolfie::itTitulo;

	    };

public:
        Wolfie();
        Conj<Cliente>::const_Iterador Clientes() const;
        Wolfie::itTitulo Titulos();
        Conj<Promesa>::Iterador promesasDe(Cliente c) ;
        Nat accionesPorCliente(Cliente c, Nombre nt);
        Wolfie inaugurarWolfie (Conj<Cliente> cs);
        void agregarTitulo(Titulo t);
        void actualizarCotizacion(Nombre nt, Nat cot);
        void agregarPromesa(Cliente c, Promesa p);
        bool enAlza(Nombre nt);

        //Esto está para facilitar el driver:
        //(Si no son const el driver explota)
        Nat cantClientes() const;
        Nat cantTitulos() const;

	itTitulo CrearItT(Wolfie* w);

};
